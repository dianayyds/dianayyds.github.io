<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>图像重建指标(mse+psnr+ssim)</title>
      <link href="/2025/04/13/tu-xiang-chong-jian-zhi-biao-mse-psnr-ssim/"/>
      <url>/2025/04/13/tu-xiang-chong-jian-zhi-biao-mse-psnr-ssim/</url>
      
        <content type="html"><![CDATA[<p><strong>MSE: Mean Square Error，均方误差</strong></p><p>假设现在有两个图像，名字分别是X和Y，其中的元素分别记为x<del>i</del>,y<del>i</del>,元素总数为N，那么MSE的计算公式为：</p><img src="/2025/04/13/tu-xiang-chong-jian-zhi-biao-mse-psnr-ssim/图像重建指标-mse-psnr-ssim/image-20250413143555458.png" alt="image-20250413143555458" style="zoom:33%;"><p>也就是最简单的逐元素比较，MSE越小说明两个图像越相近，重建质量越好。</p><p><strong>PSNR: Peak Signal to Noise Ratio，峰值信噪比</strong></p><p>PSNE是基于MSE得到的，其计算公式为：</p><img src="/2025/04/13/tu-xiang-chong-jian-zhi-biao-mse-psnr-ssim/图像重建指标-mse-psnr-ssim/image-20250413143951708.png" alt="image-20250413143951708" style="zoom:33%;"><p>其中MAX<del>I</del>是一个常数，表示图像最大动态范围，如果是float型，是1，如果是int8型，是255。</p><p>因为MSE放在了分母上，所以PSNR越大越好，在我阅读的文献中，一般30以上算是比较好的结果了。</p><p>MSE与PSNR的问题是，在计算每个位置上的像素差异时，其结果仅与当前位置的两个像素值有关，与其它任何位置上的像素无关。这也就是说，这种计算差异的方式仅仅将图像看成了一个个孤立的像素点，而忽略了图像内容所包含的一些视觉特征，特别是图像的局部语义信息。而图像质量的好坏极大程度上是一个主观感受，其中语义信息对人主观感受的影响非常之大。</p><p><strong>在介绍SSIM的计算公式前，有几个基本指标要介绍：</strong></p><p>均值：</p><img src="/2025/04/13/tu-xiang-chong-jian-zhi-biao-mse-psnr-ssim/图像重建指标-mse-psnr-ssim/image-20250413144511465.png" alt="image-20250413144511465" style="zoom:33%;"><p>标准差：</p><img src="/2025/04/13/tu-xiang-chong-jian-zhi-biao-mse-psnr-ssim/图像重建指标-mse-psnr-ssim/image-20250413144527476.png" alt="image-20250413144527476" style="zoom:33%;"><p>假设我们有另外一个图像块，像素数目也为N，其中的元素记为y<del>i</del>， 那么两个图像块减去均值后的余弦相似度公式为：</p><img src="/2025/04/13/tu-xiang-chong-jian-zhi-biao-mse-psnr-ssim/图像重建指标-mse-psnr-ssim/image-20250413144632871.png" alt="image-20250413144632871" style="zoom: 33%;"><p>其中σ<del>xy</del>表示协方差</p><img src="/2025/04/13/tu-xiang-chong-jian-zhi-biao-mse-psnr-ssim/图像重建指标-mse-psnr-ssim/image-20250413144731442.png" alt="image-20250413144731442" style="zoom:33%;"><p>SSIM的公式为：</p><img src="/2025/04/13/tu-xiang-chong-jian-zhi-biao-mse-psnr-ssim/图像重建指标-mse-psnr-ssim/image-20250413144804892.png" alt="image-20250413144804892" style="zoom:33%;"><p>其中</p><img src="/2025/04/13/tu-xiang-chong-jian-zhi-biao-mse-psnr-ssim/图像重建指标-mse-psnr-ssim/image-20250413144928535.png" alt="image-20250413144928535" style="zoom:33%;"><img src="/2025/04/13/tu-xiang-chong-jian-zhi-biao-mse-psnr-ssim/图像重建指标-mse-psnr-ssim/image-20250413144905343.png" alt="image-20250413144905343" style="zoom:33%;"><p>实际计算时，K<del>1</del>一般取0.01，k<del>2</del>一般取0.03</p><p>特别注意：按照上述方法，我们计算得到了一个图像块的SSIM值，在实际计算时，一个图像块通常取成正方形，然后将该SSIM值赋给图像块的中心位置。然后滑动这个正方形块，可以得到其他所有位置的SSIM值，于是我们就得到了一个SSIM图。然而在实际中，我们对两张图像进行计算得到的通常是一个SSIM值，这个值在文章中称为mean SSIM（MSSIM），计算方法是对SSIM图取平均：</p><img src="/2025/04/13/tu-xiang-chong-jian-zhi-biao-mse-psnr-ssim/图像重建指标-mse-psnr-ssim/image-20250413145412737.png" alt="image-20250413145412737" style="zoom: 33%;">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>milvus安装</title>
      <link href="/2025/03/07/milvus-an-zhuang/"/>
      <url>/2025/03/07/milvus-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h4 id="注意（推荐用linux，windows安装会有很多问题）"><a href="#注意（推荐用linux，windows安装会有很多问题）" class="headerlink" title="注意（推荐用linux，windows安装会有很多问题）"></a>注意（推荐用linux，windows安装会有很多问题）</h4><p>docker环境需要自己先预先配置好，鉴于网络上相关的教程已经非常成熟，我就略过了，这里需要验证docker环境是否安装成功，在命令行下输入：</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">docker</span> run hello-world</code></pre><p>如果出现如图所示的输出，那么docker环境就配置好了。</p><img src="/2025/03/07/milvus-an-zhuang/image-20250307121258115.png"><h4 id="开始安装milvus"><a href="#开始安装milvus" class="headerlink" title="开始安装milvus"></a>开始安装milvus</h4><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> milvus2<span class="token builtin class-name">cd</span> milvus2<span class="token function">wget</span> https://github.com/milvus-io/milvus/releases/download/v2.2.13/milvus-standalone-docker-compose.yml <span class="token parameter variable">-O</span> docker-compose.yml</code></pre><p><img src="/2025/03/07/milvus-an-zhuang/image-20250307121707310.png"></p><p> 查看当前文件夹，会出现一个名为docker-compose.yml的文件，打开这个文件（任意方式打开都行，记事本，vscode等等能编辑的都行，会用vim当然更好），把下面这一段粘贴进去（这里attu的版本是2.2.8，和前面安装milvus版本2.2.13是相互对应的，我试过很多版本，目前就这俩亲测好用）</p><pre class="language-bash" data-language="bash"><code class="language-bash">attu:    container_name: attu    image: zilliz/attu:v2.2.8    environment:      MILVUS_URL: <span class="token number">127.0</span>.0.1:19530    ports:      - <span class="token string">"3000:3000"</span>    depends_on:      - <span class="token string">"standalone"</span></code></pre><p>格式参考截图，attu需要和上面的standalone在同一列</p><img src="/2025/03/07/milvus-an-zhuang/image-20250307122121078.png"><p>记得保存修改，然后回到之前的命令行</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">docker-compose</span> up <span class="token parameter variable">-d</span></code></pre><p><img src="/2025/03/07/milvus-an-zhuang/image-20250307122416837.png"></p><p>​验证连接</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> port milvus-standalone <span class="token number">19530</span>/tcp</code></pre><p><img src="/2025/03/07/milvus-an-zhuang/image-20250307122718107.png"></p><p>在浏览器输入 <a href="http://localhost:3000/">http://localhost:3000</a> 进入attu可视化界面，完成</p><p><img src="/2025/03/07/milvus-an-zhuang/image-20250307122854318.png"></p>]]></content>
      
      
      <categories>
          
          <category> milvus </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大模型外挂向量知识库</title>
      <link href="/2025/02/16/da-mo-xing-wai-gua-xiang-liang-zhi-shi-ku/"/>
      <url>/2025/02/16/da-mo-xing-wai-gua-xiang-liang-zhi-shi-ku/</url>
      
        <content type="html"><![CDATA[<p><img src="/2025/02/16/da-mo-xing-wai-gua-xiang-liang-zhi-shi-ku/371f517a40a550f21cbe52b7ce8e368.png"></p><p><img src="/2025/02/16/da-mo-xing-wai-gua-xiang-liang-zhi-shi-ku/2be1eefd12f00ecff6ab4f68b9fdd96.png"></p>]]></content>
      
      
      <categories>
          
          <category> 大模型外挂向量知识库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vqvae</title>
      <link href="/2025/02/10/vqvae/"/>
      <url>/2025/02/10/vqvae/</url>
      
        <content type="html"><![CDATA[<p>VQVAE的流程图如下：</p><img src="/2025/02/10/vqvae/image-20250210160314814.png" style="zoom: 33%;"><p>VQVQE的模型搭建如下，其中ResidualBlock是残差块，用于缓解梯度消失和梯度爆炸</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">VQVAE</span><span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> input_dim<span class="token punctuation">,</span> dim<span class="token punctuation">,</span> n_embedding<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>encoder <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>input_dim<span class="token punctuation">,</span> dim<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                     nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>dim<span class="token punctuation">,</span> dim<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                     nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>dim<span class="token punctuation">,</span> dim<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                     ResidualBlock<span class="token punctuation">(</span>dim<span class="token punctuation">)</span><span class="token punctuation">,</span> ResidualBlock<span class="token punctuation">(</span>dim<span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>vq_embedding <span class="token operator">=</span> nn<span class="token punctuation">.</span>Embedding<span class="token punctuation">(</span>n_embedding<span class="token punctuation">,</span> dim<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>vq_embedding<span class="token punctuation">.</span>weight<span class="token punctuation">.</span>data<span class="token punctuation">.</span>uniform_<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1.0</span> <span class="token operator">/</span> n_embedding<span class="token punctuation">,</span>                                               <span class="token number">1.0</span> <span class="token operator">/</span> n_embedding<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>decoder <span class="token operator">=</span> nn<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span>            nn<span class="token punctuation">.</span>Conv2d<span class="token punctuation">(</span>dim<span class="token punctuation">,</span> dim<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            ResidualBlock<span class="token punctuation">(</span>dim<span class="token punctuation">)</span><span class="token punctuation">,</span> ResidualBlock<span class="token punctuation">(</span>dim<span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>ConvTranspose2d<span class="token punctuation">(</span>dim<span class="token punctuation">,</span> dim<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nn<span class="token punctuation">.</span>ReLU<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            nn<span class="token punctuation">.</span>ConvTranspose2d<span class="token punctuation">(</span>dim<span class="token punctuation">,</span> input_dim<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>n_downsample <span class="token operator">=</span> <span class="token number">2</span></code></pre><p>然后是模型的前向传播，分为编码，取最近邻，解码</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">forward</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># encode</span>    ze <span class="token operator">=</span> self<span class="token punctuation">.</span>encoder<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token comment"># ze: [N, C, H, W]</span>    <span class="token comment"># embedding [K, C]</span>    embedding <span class="token operator">=</span> self<span class="token punctuation">.</span>vq_embedding<span class="token punctuation">.</span>weight<span class="token punctuation">.</span>data    N<span class="token punctuation">,</span> C<span class="token punctuation">,</span> H<span class="token punctuation">,</span> W <span class="token operator">=</span> ze<span class="token punctuation">.</span>shape    K<span class="token punctuation">,</span> _ <span class="token operator">=</span> embedding<span class="token punctuation">.</span>shape    embedding_broadcast <span class="token operator">=</span> embedding<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> K<span class="token punctuation">,</span> C<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    ze_broadcast <span class="token operator">=</span> ze<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>N<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> C<span class="token punctuation">,</span> H<span class="token punctuation">,</span> W<span class="token punctuation">)</span>    distance <span class="token operator">=</span> torch<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>embedding_broadcast <span class="token operator">-</span> ze_broadcast<span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>    nearest_neighbor <span class="token operator">=</span> torch<span class="token punctuation">.</span>argmin<span class="token punctuation">(</span>distance<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment"># make C to the second dim</span>    zq <span class="token operator">=</span> self<span class="token punctuation">.</span>vq_embedding<span class="token punctuation">(</span>nearest_neighbor<span class="token punctuation">)</span><span class="token punctuation">.</span>permute<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token comment"># stop gradient</span>    decoder_input <span class="token operator">=</span> ze <span class="token operator">+</span> <span class="token punctuation">(</span>zq <span class="token operator">-</span> ze<span class="token punctuation">)</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># decode</span>    x_hat <span class="token operator">=</span> self<span class="token punctuation">.</span>decoder<span class="token punctuation">(</span>decoder_input<span class="token punctuation">)</span>    <span class="token keyword">return</span> x_hat<span class="token punctuation">,</span> ze<span class="token punctuation">,</span> zq</code></pre><p>取最近邻时，我们要用到两块数据：编码器输出<code>ze</code>与嵌入矩阵<code>embedding</code>。<code>ze</code>可以看成一个形状为<code>[N, H, W]</code>的数组，数组存储了长度为<code>C</code>的向量。而嵌入矩阵里有<code>K</code>个长度为<code>C</code>的向量。</p><p>为了求<code>N*H*W</code>个向量在嵌入矩阵里的最近邻，我们要先算这每个向量与嵌入矩阵里<code>K</code>个向量的距离。在算距离前，我们要把<code>embedding</code>和<code>ze</code>的形状变换一下，保证<code>(embedding_broadcast - ze_broadcast)**2</code>的形状为<code>[N, K, C, H, W]</code>。我们对这个临时结果的第2号维度（<code>C</code>所在维度）求和，得到形状为<code>[N, K, H, W]</code>的<code>distance</code>。它的含义是，对于<code>N*H*W</code>个向量，每个向量到嵌入空间里<code>K</code>个向量的距离分别是多少。</p><p>有了距离张量后，再对其1号维度（<code>K</code>所在维度）求最近邻所在下标,然后就可以从嵌入空间取出最近邻了。由于<code>self.vq_embedding(nearest_neighbor)</code>的形状会是<code>[N, H, W, C]</code>。为了与ze保持一致，要把维度转置。然后使用了梯度停止算子，解码器的输入是zq，但是梯度是直接传给ze的。</p><pre class="language-python" data-language="python"><code class="language-python">nearest_neighbor <span class="token operator">=</span> torch<span class="token punctuation">.</span>argmin<span class="token punctuation">(</span>distance<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>zq <span class="token operator">=</span> self<span class="token punctuation">.</span>vq_embedding<span class="token punctuation">(</span>nearest_neighbor<span class="token punctuation">)</span><span class="token punctuation">.</span>permute<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token comment"># stop gradient</span>decoder_input <span class="token operator">=</span> ze <span class="token operator">+</span> <span class="token punctuation">(</span>zq <span class="token operator">-</span> ze<span class="token punctuation">)</span><span class="token punctuation">.</span>detach<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>MNIST重建图像：</p><img src="/2025/02/10/vqvae/image-20250211161322458.png" style="zoom:67%;"><p>MNIST生成图像：</p><img src="/2025/02/10/vqvae/image-20250211161523434.png" style="zoom:50%;">]]></content>
      
      
      <categories>
          
          <category> vqvae </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>生成对抗网络</title>
      <link href="/2025/02/08/sheng-cheng-dui-kang-wang-luo/"/>
      <url>/2025/02/08/sheng-cheng-dui-kang-wang-luo/</url>
      
        <content type="html"><![CDATA[<p><img src="/2025/02/08/sheng-cheng-dui-kang-wang-luo/image-20250209173138879.png"></p><p>判别网络的优化目标（最大化真实图片判定为真，假图片判定为假的期望）：</p><img src="/2025/02/08/sheng-cheng-dui-kang-wang-luo/image-20250209184208419.png" style="zoom: 33%;"><p>生成网络的优化目标（最小化被判别网络判断为假的期望）：</p><img src="/2025/02/08/sheng-cheng-dui-kang-wang-luo/image-20250209184314954.png" style="zoom:33%;"><p>最终的优化函数为：</p><img src="/2025/02/08/sheng-cheng-dui-kang-wang-luo/image-20250209184459113.png" style="zoom:33%;">]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java多线程</title>
      <link href="/2024/10/31/java-duo-xian-cheng/"/>
      <url>/2024/10/31/java-duo-xian-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="创建新线程"><a href="#创建新线程" class="headerlink" title="创建新线程"></a>创建新线程</h2><p>Java语言内置了多线程支持。当Java程序启动的时候，实际上是启动了一个JVM进程，然后，JVM启动主线程来执行<code>main()</code>方法。在<code>main()</code>方法中，我们又可以启动其他线程。</p><p>要创建一个新线程非常容易，首先需要实例化一个<code>Thread</code>实例，然后覆写他的<code>run</code>方法，并调用它的<code>start()</code>方法：(要特别注意：直接调用<code>Thread</code>实例的<code>run()</code>方法是无效的)，在两个进程中使用Thread.sleep(10)可以模拟并发。</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 多线程</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main start..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 启动新线程</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"main end..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">MyThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">try</span> <span class="token punctuation">&#123;</span>            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"thread run..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"thread end."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>在Java程序中，一个线程对象只能调用一次<code>start()</code>方法启动新线程，并在新线程中执行<code>run()</code>方法。一旦<code>run()</code>方法执行完毕，线程就结束了。因此，Java线程的状态有以下几种：</p><ul><li>New：新创建的线程，尚未执行；</li><li>Runnable：运行中的线程，正在执行<code>run()</code>方法的Java代码；</li><li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li><li>Waiting：运行中的线程，因为某些操作在等待中；</li><li>Timed Waiting：运行中的线程，因为执行<code>sleep()</code>方法正在计时等待；</li><li>Terminated：线程已终止，因为<code>run()</code>方法执行完毕。</li><li>用一个状态转移图表示如下：</li></ul><img src="/2024/10/31/java-duo-xian-cheng/image-20241031124000987.png" alt="image-20241031124000987" style="zoom: 33%;"><p>当线程启动后，它可以在<code>Runnable</code>、<code>Blocked</code>、<code>Waiting</code>和<code>Timed Waiting</code>这几个状态之间切换，直到最后变成<code>Terminated</code>状态，线程终止。</p><p>线程终止的原因有：</p><ul><li>线程正常终止：<code>run()</code>方法执行到<code>return</code>语句返回；</li><li>线程意外终止：<code>run()</code>方法因为未捕获的异常导致线程终止；</li><li>对某个线程的<code>Thread</code>实例调用<code>stop()</code>方法强制终止（强烈不推荐使用）。</li></ul><p>一个线程还可以等待另一个线程直到其运行结束。例如，<code>main</code>线程在启动<code>t</code>线程后，可以通过<code>t.join()</code>等待<code>t</code>线程结束后再继续运行：</p><pre class="language-java" data-language="java"><code class="language-java"><span class="token comment">// 多线程</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Thread</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token punctuation">&#123;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"start"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 启动t线程</span>        t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 此处main线程会等待t结束</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"end"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h2>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>golang常见问题</title>
      <link href="/2024/09/17/golang-chang-jian-wen-ti/"/>
      <url>/2024/09/17/golang-chang-jian-wen-ti/</url>
      
        <content type="html"><![CDATA[<ol><li>make 和 new 的区别﹖</li><li>了解过golang的内存管理吗?</li><li>调用函数传入结构体时，应该传值还是指针﹖说出你的理由?</li><li>线程有几种模型?Goroutine的原理了解过吗，讲一下实现和优势?</li><li>Goroutine什么时候会发生阻塞?</li><li>PMG模型中Goroutine有哪几种状态?</li><li>每个线程&#x2F;协程占用多少内存知道吗?</li><li>如果Goroutine—直占用资源怎么办,PMG模型怎么解决的这个问题?</li><li>如果若干线程中一个线程OOM，会发生什么?如果是Goroutine 呢?项目中出现过OOM吗，怎么解决的?</li><li>项目中错误处理是怎么做的?</li><li>如果若干个Goroutine,其中有一个panic，会发生什么?</li><li>defer可以捕获到其Goroutine的子Goroutine 的panic吗?</li><li>开发用Gin框架吗?Gin怎么做参数校验?</li><li>中间件使用过吗?怎么使用的。Gin的错误处理使用过吗?Gin中自定义校验规则知道怎么做吗?自定义校验器的返回值呢?</li><li>golang中解析tag是怎么实现的？反射原理是什么？通过反射调用函数</li><li>golang的锁机制了解过吗? Mutex的锁有哪几种模式，分别介绍一下? Mutex锁底层如何实现了解过吗?</li><li>channel、channel使用中需要注意的地方？</li><li>数据库用的什么？数据库锁有了解吗？mysql锁机制讲一下。mysql分库分表。</li><li>讲一下redis分布式锁？redis主从模式和集群模式的区别了解过吗？redis的数据类型有哪些？redis持久化怎么做的？</li><li>编程题：你了解的负载均衡算法有什么？实现一个负载均衡算法。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Golang必学概念 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Context</title>
      <link href="/2024/09/16/context/"/>
      <url>/2024/09/16/context/</url>
      
        <content type="html"><![CDATA[<p><code>context</code> 常用于以下几种情况：</p><ul><li>数据传递： 在多个 <code>goroutine</code> 中传递数据</li><li>超时管理： 通过配置超时时间，可以方便地配置协程的终止时间</li><li>终止协程： 通过使用 <code>cancel()</code> 方法，协程s可以很方便地终止，可以批量管理多个协程的终止</li></ul><h3 id="根节点和派生结点"><a href="#根节点和派生结点" class="headerlink" title="根节点和派生结点"></a>根节点和派生结点</h3><p>我们可以为 <code>context</code> 创建根节点和派生节点，为树形结构，当根节点被 <code>cancel()</code> 或超时终止时，它的所有派生节点也会被终止，根节点的数据也会被所有派生节点共享。</p><p><img src="/2024/09/16/context/context.png" alt="context"></p><h3 id="创建根节点"><a href="#创建根节点" class="headerlink" title="创建根节点"></a>创建根节点</h3><pre class="language-go" data-language="go"><code class="language-go">ctx <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 创建空白 context</span>ctx2 <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">TODO</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// TODO 同样是空白 context</span></code></pre><h3 id="创建派生结点"><a href="#创建派生结点" class="headerlink" title="创建派生结点"></a>创建派生结点</h3><p>使用 <code>context.WithXXX()</code> 创建派生 <code>context</code></p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"context"</span><span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>ctx <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithValue</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"base"</span><span class="token punctuation">,</span> <span class="token string">"baseVal"</span><span class="token punctuation">)</span>ctx1 <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithValue</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> <span class="token string">"ctx1"</span><span class="token punctuation">,</span> <span class="token string">"ctx1Val"</span><span class="token punctuation">)</span>ctx2 <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithValue</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> <span class="token string">"ctx2"</span><span class="token punctuation">,</span> <span class="token string">"ctx2Val"</span><span class="token punctuation">)</span>ctx3 <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithValue</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> <span class="token string">"ctx3"</span><span class="token punctuation">,</span> <span class="token string">"ctx3Val"</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>ctx1<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>ctx2<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>ctx3<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 结果：</span><span class="token comment">// context.Background.WithValue(type string, val baseVal)</span><span class="token comment">// context.Background.WithValue(type string, val baseVal).WithValue(type string, val ctx1Val)</span><span class="token comment">// context.Background.WithValue(type string, val baseVal).WithValue(type string, val ctx2Val)</span><span class="token comment">// context.Background.WithValue(type string, val baseVal).WithValue(type string, val ctx3Val)</span></code></pre><p><code>context.WithValue()</code> 可以用于创建派生节点并添加键值数据，同时保留父级 context 所有的数据</p><p>context.WithDeadline()和 context.WithTimeout() 可以用来创建带有超时控制的 context</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"context"</span><span class="token string">"fmt"</span><span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>ctx<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithTimeout</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>ctx1 context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span><span class="token keyword">select</span> <span class="token punctuation">&#123;</span><span class="token keyword">case</span> <span class="token operator">&lt;-</span>ctx1<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"time out"</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token keyword">default</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"running..."</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 结果：</span><span class="token comment">// running...</span><span class="token comment">// running...</span><span class="token comment">// running...</span><span class="token comment">// time out</span></code></pre><p>使用 <code>WithCancel()</code> 可以创建手动终止的 <code>context</code> 执行 <code>cancel()</code> 即可手动终止</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"context"</span><span class="token string">"fmt"</span><span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>ctx<span class="token punctuation">,</span> cancel <span class="token operator">:=</span> context<span class="token punctuation">.</span><span class="token function">WithCancel</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>ctx1 context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span><span class="token keyword">select</span> <span class="token punctuation">&#123;</span><span class="token keyword">case</span> <span class="token operator">&lt;-</span>ctx1<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"canceled"</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token keyword">default</span><span class="token punctuation">:</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"running..."</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token comment">// 结果：</span><span class="token comment">// running...</span><span class="token comment">// running...</span><span class="token comment">// running...</span><span class="token comment">// canceled</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Golang必学概念 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>channel</title>
      <link href="/2024/09/16/channel/"/>
      <url>/2024/09/16/channel/</url>
      
        <content type="html"><![CDATA[<h3 id="创建channel"><a href="#创建channel" class="headerlink" title="创建channel"></a>创建channel</h3><pre class="language-go" data-language="go"><code class="language-go">ch1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> T<span class="token punctuation">)</span> <span class="token comment">// 无缓冲</span>ch2 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> T<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 带缓冲</span></code></pre><p>T为数据类型</p><p>注意</p><ul><li>无缓冲区的信道会被阻塞直到数据被接收</li><li>有缓冲区的信道在发送的数据达到缓冲区大小后才会被阻塞</li></ul><h3 id="发送接收数据"><a href="#发送接收数据" class="headerlink" title="发送接收数据"></a>发送接收数据</h3><p>使用 <code>&lt;-</code> 指向 channel 表示发送数据到该 channel, 如 <code>ch &lt;- 10</code></p><p>使用 <code>&lt;-</code> 在 channel 左侧表示接收数据，如 <code>&lt;-ch</code></p><h3 id="关闭channel"><a href="#关闭channel" class="headerlink" title="关闭channel"></a>关闭channel</h3><p>使用 <code>close()</code> 关闭 <code>channel</code></p><pre class="language-go" data-language="go"><code class="language-go"><span class="token function">close</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span></code></pre><p>注意</p><ul><li>如果往一个已经 <code>close()</code> 的 <code>channel</code> 发送消息，会产生 <code>panic</code></li><li>读取已关闭的 <code>channel</code> 可以获得零值, 若使用 <code>range</code> 读取 <code>channel</code>, 则 <code>close</code> 后会终止循环</li></ul><p>我们可以使用 <code>val, ok := &lt;- ch</code> 来判断是否是零值，若 <code>ok</code> 为 <code>false</code> 则信道已经 <code>close</code></p><h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><p>通常我们会使用 <code>select</code> 来接收 <code>channel</code> 的数据, 还可以使用 <code>default</code> 设定默认执行的动作, <code>select</code> 可以同时接收多个 <code>channel</code> ，若多个 <code>channel</code> 同时发送过来数据，则会随机选择一个 <code>channel</code> 完成操作</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">select</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">case</span> <span class="token operator">&lt;-</span>ch1<span class="token punctuation">:</span>  <span class="token comment">// 接收 ch1 的数据</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ch1"</span><span class="token punctuation">)</span>      <span class="token keyword">case</span> <span class="token operator">&lt;-</span>ch2<span class="token punctuation">:</span> <span class="token comment">// 接收 ch2 的数据</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"ch2"</span><span class="token punctuation">)</span>    <span class="token keyword">case</span> val <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch3<span class="token punctuation">:</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>ch3<span class="token punctuation">)</span> <span class="token comment">//接收 ch3 的数据并打印</span>    <span class="token keyword">default</span><span class="token punctuation">:</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"default"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><p>定时器就是通过 <code>channel</code> 实现了定时结果的返回</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>t <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">NewTicker</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"start"</span><span class="token punctuation">)</span><span class="token operator">&lt;-</span>t<span class="token punctuation">.</span>Cfmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"finish"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><p>程序启动后会在三秒时准时结束。</p>]]></content>
      
      
      <categories>
          
          <category> Golang必学概念 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Goroutine</title>
      <link href="/2024/09/16/goroutine/"/>
      <url>/2024/09/16/goroutine/</url>
      
        <content type="html"><![CDATA[<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li><strong>轻量级</strong>：Goroutine 的栈空间初始大小只有 2KB，可以动态扩容，最大可达 1GB</li><li><strong>快速启动</strong>：Goroutine 的启动时间只有 1~2us</li><li><strong>高效调度</strong>：Goroutine 的调度器采用 M:N 模型，可以将 M 个 Goroutine 映射到 N 个 OS 线程上，实现高效调度</li><li><strong>通信简单</strong>：Goroutine 之间通过 Channel 进行通信，实现数据共享</li><li><strong>无锁</strong>：Goroutine 之间通过 Channel 进行通信，无需加锁</li><li><strong>高并发</strong>：Goroutine 可以轻松创建数十万个，实现高并发</li><li><strong>高性能</strong>：Goroutine 的调度器采用抢占式调度，实现高性能</li></ul><h3 id="创建Goroutine"><a href="#创建Goroutine" class="headerlink" title="创建Goroutine"></a>创建Goroutine</h3><p>由于 Goroutine 是 Golang 非常重视的基本功能，因此在 Golang 中创建异步 Goroutine 非常简单，只需要在函数调用前加上 <code>go</code> 关键字即可，比绝大部分的编程语言都要简单。</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">for</span> <span class="token punctuation">&#123;</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"running..."</span><span class="token punctuation">)</span>            time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><p>使用 <code>go</code> 加上任意 <code>func</code> 即可创建一个 Goroutine，Goroutine 会在后台执行，不会阻塞主线程。</p><h3 id="停止-Goroutine"><a href="#停止-Goroutine" class="headerlink" title="停止 Goroutine"></a>停止 Goroutine</h3><ul><li><strong>运行结束</strong>：Goroutine 会在函数运行结束后自动结束</li><li><strong>超时结束</strong>：通过 <code>context.WithTimeout()</code> 或 <code>context.WithDeadline()</code> 可以设置 Goroutine 的超时时间</li><li><strong>手动结束</strong>：通过 <code>context.WithCancel()</code> 可以手动结束 Goroutine</li><li><strong>通道结束</strong>：通过 Channel 通信，可以结束 Goroutine</li></ul><h3 id="Goroutine和Channel"><a href="#Goroutine和Channel" class="headerlink" title="Goroutine和Channel"></a>Goroutine和Channel</h3><p>我们知道，无论是在线程还是协程，在运行的时候都会遇到共享数据或传递数据的情况，在 Golang 中，我们可以通过 Channel 来实现 Goroutine 之间的通信。</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"fmt"</span>    <span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">select</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">case</span> <span class="token operator">&lt;-</span>ch<span class="token punctuation">:</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"exit"</span><span class="token punctuation">)</span>            <span class="token keyword">return</span>        <span class="token keyword">default</span><span class="token punctuation">:</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"running..."</span><span class="token punctuation">)</span>            time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>ch <span class="token operator">&lt;-</span> <span class="token number">1</span><span class="token punctuation">&#125;</span></code></pre><p>在上面的例子中，我们创建了一个 Channel <code>ch</code>，在主线程中向 <code>ch</code> 中发送了一个数据，Goroutine 中通过 <code>select</code> 语句监听 <code>ch</code>，当 <code>ch</code> 中有数据时，Goroutine 会退出。</p><p>协程之间通过 Channel 通信的例子：</p><pre class="language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span><span class="token string">"fmt"</span><span class="token string">"time"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">sendData</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token keyword">go</span> <span class="token function">getData</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">sendData</span><span class="token punctuation">(</span>ch <span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>ch <span class="token operator">&lt;-</span> <span class="token string">"ycx"</span>ch <span class="token operator">&lt;-</span> <span class="token string">"hexo"</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">getData</span><span class="token punctuation">(</span>ch <span class="token keyword">chan</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">var</span> input <span class="token builtin">string</span><span class="token keyword">for</span> <span class="token punctuation">&#123;</span>input <span class="token operator">=</span> <span class="token operator">&lt;-</span>chfmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s "</span><span class="token punctuation">,</span> input<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">// 结果: ycx hexo</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Golang必学概念 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2024/07/27/dong-tai-gui-hua/"/>
      <url>/2024/07/27/dong-tai-gui-hua/</url>
      
        <content type="html"><![CDATA[<p>​动态规划（Dynamic Programming,DP）算法通常用于求解某种具有最优性质的问题。在这类问题中，可能会有许多可行解，每一个解都对应一个值，我们希望找到具有最优值的解。</p><p>​动态规划算法与分治法类似，其基本思想也是将待求解的问题分解成若干个子问题，先求解子问题，然后从这些子问题的解中 得到原有问题的解。与分治法不同的是，动态规划经分解后得到的子问题往往不是相互独立的。</p><h4 id="01背包："><a href="#01背包：" class="headerlink" title="01背包："></a>01背包：</h4><pre class="language-c++" data-language="c++"><code class="language-c++">fix(i,j)&#x3D;max(fix(i-1,j),fix(i-1,j-v)+w);</code></pre><h4 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包:"></a>完全背包:</h4><pre class="language-c++" data-language="c++"><code class="language-c++">fix(i,j)&#x3D;max(fix(i-1,j),fix(i,j-v)+w);</code></pre><h4 id="背包问题求方案数：（设置一个cnt数组初始化为1，与dp同步更改）"><a href="#背包问题求方案数：（设置一个cnt数组初始化为1，与dp同步更改）" class="headerlink" title="背包问题求方案数：（设置一个cnt数组初始化为1，与dp同步更改）"></a>背包问题求方案数：（设置一个cnt数组初始化为1，与dp同步更改）</h4><pre class="language-c++" data-language="c++"><code class="language-c++">const int N &#x3D; 1010;const int mod&#x3D;1e9+7;int f[N];int g[N];int cnt[N];int cntt[N];int main( ) &#123;int n, v;cin &gt;&gt; n &gt;&gt; v;for (int i &#x3D; 0; i &lt;&#x3D; v; i++)cnt[i] &#x3D; 1;for (int i &#x3D; 0; i &lt; n; i++) &#123;memcpy(g, f, sizeof(f));memcpy(cntt, cnt, sizeof(cntt));int a, b;cin &gt;&gt; a &gt;&gt; b;for (int j &#x3D; a; j &lt;&#x3D; v; j++) &#123;int x &#x3D; g[j - a] + b;if (x &gt; g[j]) &#123;cnt[j] &#x3D; cntt[j - a];f[j] &#x3D; x;&#125; else if (x &#x3D;&#x3D; g[j]) &#123;cnt[j] &#x3D; (cntt[j] + cntt[j - a])%mod;&#125;&#125;&#125;cout &lt;&lt; cnt[v]%mod;return 0;&#125;</code></pre><h4 id="树形dp（有依赖的背包问题）："><a href="#树形dp（有依赖的背包问题）：" class="headerlink" title="树形dp（有依赖的背包问题）："></a>树形dp（有依赖的背包问题）：</h4><pre class="language-c++" data-language="c++"><code class="language-c++">const int N &#x3D; 110;int e[N], ne[N], idx, h[N];int v[110];int w[110];int n, V;int f[110][110];int g[110][110];void add(int a, int b) &#123;e[idx] &#x3D; b;ne[idx] &#x3D; h[a];h[a] &#x3D; idx++;&#125;&#x2F;&#x2F;p是根节点，先假设当前节点必须选，那么他的子树就是分组背包void dfs(int a) &#123;for (int i &#x3D; v[a]; i &lt;&#x3D; V; i++) &#123;f[a][i] &#x3D; w[a];&#125;for (int u &#x3D; h[a]; u !&#x3D; -1; u &#x3D; ne[u]) &#123;int b &#x3D; e[u];dfs(b);&#125;for (int u &#x3D; h[a]; u !&#x3D; -1; u &#x3D; ne[u]) &#123;memcpy(g,f,sizeof(f));int b &#x3D; e[u];for(int i&#x3D;v[a];i&lt;&#x3D;V;i++)&#123;for (int z &#x3D; v[b]; z &lt;&#x3D; i-v[a]; z++) f[a][i] &#x3D; max(f[a][i],max(g[a][i], g[a][i - z] + g[b][z]));    &#125;&#125;&#125;</code></pre><h4 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包:"></a>多重背包:</h4><p>二进制化简法：对于有s个物品的物品，将s分解为1+2+4+….pow(2,k)+s的背包，从而化简为01背包</p><pre class="language-c++" data-language="c++"><code class="language-c++">int k &#x3D; 1;while (k &lt; s)&#123;vi[cnt] &#x3D; v * k;wi[cnt] &#x3D; w * k;s &#x3D; s - k;k &#x3D; k * 2;cnt++;&#125;            vi[cnt] &#x3D; v * s;wi[cnt] &#x3D; w * s;cnt++;</code></pre><h4 id="单调队列："><a href="#单调队列：" class="headerlink" title="单调队列："></a>单调队列：</h4><p>（滑动窗口求最大值）q队列保存下标</p><pre class="language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;        vector&lt;int&gt; ans;        int q[100000+10];        int hh&#x3D;0,tt&#x3D;-1;        for(int i&#x3D;0;i&lt;nums.size();i++)        &#123;            tt++;            q[tt]&#x3D;i;            if(q[tt]-q[hh]&gt;&#x3D;k)            hh++;            while(hh&lt;tt&amp;&amp;nums[q[tt-1]]&lt;nums[q[tt]])            &#123;                tt--;                q[tt]&#x3D;i;            &#125;                        if(i&gt;&#x3D;k-1)            ans.push_back(nums[q[hh]]);        &#125;        return ans;    &#125;</code></pre><h4 id="多重背包究极版："><a href="#多重背包究极版：" class="headerlink" title="多重背包究极版："></a>多重背包究极版：</h4><p>（使用拷贝数组） 注意到每一个模v的同余组，是相互独立的，且最大同时存在值一定，那么可以使用单调队列计算每一个窗口里面最大值，这里并不是直接把f中的数字拿出来，而是单纯比较，用队列存取较大值的下标。</p><pre class="language-c++" data-language="c++"><code class="language-c++">const int N &#x3D; 20010;int f[N];int g[N];int q[N];int main( ) &#123;int n, V;cin &gt;&gt; n &gt;&gt; V;for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;int v, w, s;cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;&#x2F;&#x2F;体积，价值，数量memcpy(g,f,sizeof(f));for (int j &#x3D; 0; j &lt; v; j++) &#123;int hh &#x3D; 0, tt &#x3D; -1;&#x2F;&#x2F;模拟单调队列for (int z &#x3D; j; z &lt;&#x3D; V; z &#x3D; z + v) &#123;tt++;q[tt] &#x3D; z;if (hh &lt; tt &amp;&amp; (q[tt] - q[hh]) &#x2F; v &gt; s )hh++;while (hh &lt; tt &amp;&amp; (q[tt] - q[tt - 1]) &#x2F; v * w + g[q[tt - 1]] &lt;&#x3D; g[q[tt]]) &#123;q[tt - 1] &#x3D; q[tt];tt--;&#125;f[z] &#x3D; g[q[hh]] + (z - q[hh]) &#x2F; v * w;&#125;&#125;&#125;cout &lt;&lt; f[V];return 0;&#125;</code></pre><h4 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h4><p>初始化：数组中的第一个数<br>循环数组的所有数，若该数小于已有序列的最大数，则把该数代替已有序列中第一个大于他的数（二分查找）,且该数的dp值就是这个数在序列中的位置，总复杂度nlog(n),最后得到最大序列长度即为所求;</p><h4 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h4><pre class="language-c++" data-language="c++"><code class="language-c++">for (int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;for (int j &#x3D; 1; j &lt;&#x3D; m; j++)&#123;dp[i][j] &#x3D; max(dp[i - 1][j], dp[i][j - 1]);if (a[i-1] &#x3D;&#x3D; b[j-1])dp[i][j] &#x3D; max(dp[i][j], dp[i - 1][j - 1] + 1);&#125;&#125;</code></pre><p>寻找最少的上升子序列数量：核心思想是贪心，对于每一个数，要么加入比他小的第一个数的后面，要么重新开一个序列，比如6,4,2那么5就要把4替换掉，1就直接push_back，注意到上升子序列的vector是降序，下降子序列是升序。</p><pre class="language-c++" data-language="c++"><code class="language-c++">for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;if (!f.size()) &#123;f.push_back(an[i]);&#125; else if (f[f.size() - 1] &lt; an[i]) &#123;f.push_back(an[i]);&#125; elsefor (int j &#x3D; 0; j &lt; f.size(); j++) &#123;if (an[i] &lt;&#x3D; f[j]) &#123;f[j] &#x3D; an[i];break;&#125;&#125;&#125;int ans2 &#x3D; f.size();int ans1 &#x3D; 0;for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;for (int j &#x3D; 0; j &lt; i; j++) &#123;if (an[j] &gt;&#x3D; an[i]) &#123;w[i] &#x3D; max(w[i], w[j] + 1);ans1 &#x3D; max(ans1, w[i]);&#125;&#125;&#125;</code></pre><h4 id="最短编辑距离"><a href="#最短编辑距离" class="headerlink" title="最短编辑距离"></a>最短编辑距离</h4><p>（两个字符串编辑dp[i][j]次后相等）</p><pre class="language-c++" data-language="c++"><code class="language-c++">void help(int a, int b, string s1, string s2)&#x2F;&#x2F;s1.size&#x3D;a,s2.size&#x3D;b;&#123;for (int i &#x3D; 0; i &lt;&#x3D; b; i++)&#x2F;&#x2F;初始化&#123;dp[0][i] &#x3D; i;&#125;for (int i &#x3D; 0; i &lt;&#x3D; a; i++)&#x2F;&#x2F;初始化&#123;dp[i][0] &#x3D; i;&#125;for (int i &#x3D; 1; i &lt;&#x3D; a; i++)&#123;for (int j &#x3D; 1; j &lt;&#x3D; b; j++)&#123;if (s1[i-1] &#x3D;&#x3D; s2[j-1])&#123;dp[i][j] &#x3D; minn(dp[i - 1][j - 1], dp[i - 1][j] + 1, dp[i][j - 1] + 1);&#125;else&#123;dp[i][j] &#x3D; minn(dp[i - 1][j - 1]+1, dp[i - 1][j] + 1, dp[i][j - 1] + 1);&#125;&#125;&#125;&#125;</code></pre><h4 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h4><p>每堆石子有一定的质量，可以用一个整数来描述，现在要将这 N堆石子合并成为一堆。每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。特别的，如果是环形石子，可以初始化为2n倍，后面的是前面的复制，比如说：1,3,2,5,2 -&gt; 1,3,2,5,2,1,3,2,5,2 正常求，然后求[1-1+n-1]的最大值就可以了。</p><pre class="language-c++" data-language="c++"><code class="language-c++">for (int i &#x3D; 1; i &lt;&#x3D; n; i++)&#x2F;&#x2F;初始化&#123;dp[i][i] &#x3D; 0;&#125;for (int i &#x3D; 2; i &lt;&#x3D; n; i++)&#123;for (int j &#x3D; i - 1; j &gt;&#x3D; 1; j--)&#123;for (int k &#x3D; j; k &lt; i; k++)&#123;dp[j][i] &#x3D; min(dp[j][i],dp[j][k]+ dp[k + 1][i]);&#125;dp[j][i] &#x3D; dp[j][i] + s[i] - s[j - 1];&#125;&#125;</code></pre><h4 id="状态机："><a href="#状态机：" class="headerlink" title="状态机："></a>状态机：</h4><p>0是持有股票的状态，1是未持有股票的状态，除了f[0][0][0]以外f[0][0-k][0,1]都是不合法的，f[1-n][0][0]也是不合法的。</p><pre class="language-c++" data-language="c++"><code class="language-c++">const int N &#x3D; 1e5 + 10, INF &#x3D; 0x3f3f3f3f;int f[N][110][2];int w[N];int main() &#123;int n, k;cin &gt;&gt; n &gt;&gt; k;for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;cin &gt;&gt; w[i];&#125;memset(f, 0, sizeof(f));for (int i &#x3D; 0; i &lt;&#x3D; k; i++) &#123;f[0][i][0] &#x3D; -INF;f[0][i][1] &#x3D; -INF;&#125;for (int i &#x3D; 0; i &lt;&#x3D; n; i++) &#123;f[i][0][0] &#x3D; -INF;&#125;f[0][0][1] &#x3D; 0;for (int i &#x3D; 1; i &lt;&#x3D; n; i++)for (int j &#x3D; 1; j &lt;&#x3D; k; j++) &#123;f[i][j][0] &#x3D; max(f[i - 1][j - 1][1] - w[i], f[i - 1][j][0]);f[i][j][1] &#x3D; max(f[i - 1][j][1], f[i - 1][j][0] + w[i]);&#125;int ans &#x3D; 0;for (int i &#x3D; 1; i &lt;&#x3D; k; i++) &#123;ans &#x3D; max(ans, max(f[n][i][0], f[n][i][1]));&#125;cout &lt;&lt; ans;return 0;&#125;</code></pre><h4 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h4><p>主要先找出来一行所有合法的状态，在这一行合法的状态中找出两两合法的上下行，遍历。</p><pre class="language-c++" data-language="c++"><code class="language-c++">typedef long long ll;const int N &#x3D; 1 &lt;&lt; 12, M &#x3D; 110;vector&lt;int&gt; state;vector&lt;int&gt; head[N];ll f[13][M][N];int cnt[N];int n, k;bool check(int a) &#123;    for (int i &#x3D; 0; i &lt; n; i++) &#123;        if ((a &gt;&gt; i &amp; 1) &amp;&amp; (a &gt;&gt; i + 1 &amp; 1))            return false;    &#125;    return true;&#125;int countt(int a) &#123;    int res &#x3D; 0;    for (int i &#x3D; 0; i &lt; n; i++) &#123;        res +&#x3D; a &gt;&gt; i &amp; 1;    &#125;    return res;&#125;int main() &#123;    cin &gt;&gt; n &gt;&gt; k;    for (int i &#x3D; 0; i &lt; 1 &lt;&lt; n; i++) &#123;        if (check(i)) &#123;            state.push_back(i);        &#125;    &#125;    for (int i &#x3D; 0; i &lt; state.size(); i++) &#123;        cnt[i] &#x3D; countt(state[i]);    &#125;    for (int i &#x3D; 0; i &lt; state.size(); i++) &#123;        for (int j &#x3D; 0; j &lt; state.size(); j++) &#123;            if (check(state[i] | state[j]) &amp;&amp; (state[i] &amp; state[j]) &#x3D;&#x3D; 0) &#123;                head[i].push_back(j);            &#125;        &#125;    &#125;    memset(f, 0, sizeof(f));    f[0][0][0] &#x3D; 1;    for (int i &#x3D; 1; i &lt;&#x3D; n + 1; i++) &#123;        for (int j &#x3D; 0; j &lt;&#x3D; k; j++) &#123;            for (int a &#x3D; 0; a &lt; state.size(); a++) &#123;                for (auto b : head[a]) &#123;                    if (j &gt;&#x3D; cnt[a])                        f[i][j][a] +&#x3D; f[i - 1][j - cnt[a]][b];                &#125;            &#125;        &#125;    &#125;    cout &lt;&lt; f[n + 1][k][0];    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法小技巧</title>
      <link href="/2024/07/27/suan-fa-xiao-ji-qiao/"/>
      <url>/2024/07/27/suan-fa-xiao-ji-qiao/</url>
      
        <content type="html"><![CDATA[<p>众所周知，longlong不开见祖宗，每年都有很多人因此而吃亏，包括我自己，long long int 的上界建议定为1e18</p><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;万能头#include&lt;bits&#x2F;stdc++.h&gt;ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</code></pre><p>lower_bound返回数组中第一个大于等于k的迭代器，upper_bound返回数组中第一个大于k的迭代器,实现为二分，使用方法如下：</p><pre class="language-c++" data-language="c++"><code class="language-c++">int an[]:1 1 1 2 2 3 3lower_bound(an,an+7,2)-an  &#x2F;&#x2F;为3upper_bound(an,an+7,2)-an  &#x2F;&#x2F;为4vector&lt;int&gt; an:1 1 1 2 2 3 3lower_bound(an,begin(),an.end(),2)-an.begin() &#x2F;&#x2F;为3upper_bound(an,begin(),an.end(),2)-an.begin() &#x2F;&#x2F;为4</code></pre><p>double不够时用long double,注意printf的时候double用%.nlf,long double用%.nLf.</p><p>一个vector类型的size是unsigned long long ,如果减去一个数为负数，会发生越界，注意要强制转化</p><p>输出int时带前导0，比如<br>printf(“%05d”,res)<br>若res位数大于5，则输出res，否则前面补0输出5位</p><p>自创数据：<br>新创一个cpp文件：</p><pre class="language-c++" data-language="c++"><code class="language-c++">int main() &#123;freopen(&quot;test.txt&quot;, &quot;w&quot;, stdout);cout &lt;&lt; 1 &lt;&lt; &quot;\n&quot;;return 0;&#125;</code></pre><p>在代码文件里直接访问：</p><pre class="language-c++" data-language="c++"><code class="language-c++">freopen(&quot;test.txt&quot;, &quot;r&quot;, stdin);</code></pre><p>set容器使用：不允许重复，不排序</p><pre class="language-c++" data-language="c++"><code class="language-c++">struct cmp&#123;    bool operator()(pi a,pi b) const    &#123;        if(a.x!&#x3D;b.x)        &#123;            return a.x&gt;b.x;&#x2F;&#x2F;按照第一个从大到小排列        &#125;        else&#123;            return a.y&lt;b.y;&#x2F;&#x2F;第一个相等的时候按照第二个元素从小到大排列        &#125;    &#125;&#125;;set&lt;pi,cmp&gt; g;&#x2F;&#x2F;也可以写成set&lt;pi,greater&lt;pi&gt;&gt; g;    g.insert(&#123;1,2&#125;);    g.insert(&#123;3,5&#125;);    g.insert(&#123;3,4&#125;);    g.insert(&#123;4,2&#125;);    g.erase(&#123;5,2&#125;);    for(auto it&#x3D;g.begin();it!&#x3D;g.end();it++)    &#123;        cout&lt;&lt;it-&gt;x&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;y&lt;&lt;&quot;\n&quot;;    &#125;</code></pre><p>erase没有删除的时候不会报错<br>输出：<br>4 2<br>3 4<br>3 5<br>1 2</p><p>multiset容器：允许重复的set，排序</p><p>常用二维数组转化为一维：a和b必须是从0开始</p><pre class="language-c++" data-language="c++"><code class="language-c++">int get(int a,int b)&#123;    return a*n+b;&#125;</code></pre><p>在unordered_map中使用pair</p><pre class="language-c++" data-language="c++"><code class="language-c++">struct pair_hash&#123;    template&lt;class T1, class T2&gt;    std::size_t operator() (const std::pair&lt;T1, T2&gt;&amp; p) const    &#123;        auto h1 &#x3D; std::hash&lt;T1&gt;&#123;&#125;(p.first);        auto h2 &#x3D; std::hash&lt;T2&gt;&#123;&#125;(p.second);        return h1 ^ h2;    &#125;&#125;;</code></pre><p>map使用count来查看是否存在元素</p><pre class="language-c++" data-language="c++"><code class="language-c++">unordered_map&lt;pair&lt;int, bool&gt;, int, pair_hash&gt; Map;pair&lt;int, int&gt; res &#x3D; &#123;1, 2&#125;;Map[res] &#x3D; 3;cout &lt;&lt; Map.count(&#123;1, 2&#125;);输出:1</code></pre><p>全排列：</p><pre class="language-c++" data-language="c++"><code class="language-c++">vector&lt;int &gt;a;for (int i &#x3D; 1; i &lt;&#x3D; 5; i++)a.push_back(i);while (next_permutation(a.begin(), a.end())) &#123;for (int i &#x3D; 0; i &lt; 5; i++)cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;;cout &lt;&lt; &quot;\n&quot;;&#125;</code></pre><p>string的substr函数：<br>string a&#x3D;”abcd”<br>cout&lt;&lt;a.substr(0,2);<br>输出：从下标0开始的长度为2的子串，即“ab”<br>cout&lt;&lt;a.substr(1,3);<br>输出：从下标1开始的长度为3的子串，即“bcd”</p><p>结构体排序：return ture则a在b前面</p><pre class="language-c++" data-language="c++"><code class="language-c++">struct Stone &#123;int s, e, l;&#125; stone[110];bool cmp(const Stone a, const Stone b) &#123;int x &#x3D; a.s * b.l;int y &#x3D; b.s * a.l;if (x &#x3D;&#x3D; y)return a.e &gt; b.e;elsereturn x &lt; y;&#125;sort(an, an + n , cmp);</code></pre><p>pair排序(使用sort)</p><pre class="language-c++" data-language="c++"><code class="language-c++">bool cmp(pi a, pi b) &#123;return a.first &lt; b.first;&#125;sort(an, an + n , cmp);&#x2F;&#x2F;从下标0到n排序，按照第一个元素从小到大排序</code></pre><p>优先队列对结构体建立小根堆（队头为最小值）需要重载大于号</p><pre class="language-c++" data-language="c++"><code class="language-c++">struct node &#123;int dist, u, type;bool operator&gt;(const node a) const &#123;return dist &gt; a.dist;&#125;&#125;;priority_queue&lt;node, vector&lt;node&gt;, greater&lt;node&gt;&gt; heap;</code></pre><p>优先队列对结构体建立大根堆（队头为最大值）需要重载小于号</p><pre class="language-c++" data-language="c++"><code class="language-c++">struct node &#123;int dist, u, type;bool operator&lt;(const node a) const &#123;return dist &lt; a.dist;&#125;&#125;;priority_queue&lt;node, vector&lt;node&gt;, less&lt;node&gt;&gt; heap;</code></pre><p>注意auto修改值的时候要加&amp;</p><p>unordered_map<string bool> ans;<br>初始化为bool是false</string></p><p>若二维数组为局部变量，各元素的值不确定。例如：一个局部变量a[4][4]未初始化值<br>若二维数组为全局变量，各元素的值编译器会默认初始化为0;例如：全局变量a[4][4]未初始化</p><p>结构体初始化：需要有默认形参，不然定义结构体数组会报错。</p><pre class="language-c++" data-language="c++"><code class="language-c++">struct ddata&#123;    int d,u,r;    ddata(int dd&#x3D;0,int uu&#x3D;0,int rr&#x3D;0):d(dd),u(uu),r(rr)&#123;&#125;&#125;;</code></pre><p>位运算<br>求x的二进制的第k位：</p><pre class="language-c++" data-language="c++"><code class="language-c++">x&gt;&gt;k&amp;1;</code></pre><p>比如：10010&gt;&gt;3&amp;1  为0</p><p>返回x的最后一个1：</p><pre class="language-c++" data-language="c++"><code class="language-c++">int lowbit(int a)&#123;       return a&amp;-a;&#125;lowbit(x)</code></pre><p>lowbit常用于树状数组</p><p>比如：lowbit(18):2(18为10010即返回10)</p><p>memset使用：<br>int:<br>-1 0 为本值<br>127为INT_MAX，0x3f为较大值，且值为0x3f3f3f3f<br>128为INT_MIN<br>double:<br>0x7f为最大值，0xfe为最小值<br>0x42为很大值，0xc2为很小值</p><p>精度问题：<br>使用double时候如果出现分数，可能导致相等的两个数不一样，用equal函数查看a和b是否相等：</p><pre class="language-c++" data-language="c++"><code class="language-c++">bool equal(double a, double b) &#123;if (fabs(a - b) &lt; eps)return true;return false;&#125;</code></pre><p>大顶堆：top是最大值</p><pre class="language-c++" data-language="c++"><code class="language-c++">#define x first#define y secondstruct cmp &#123;bool operator()(pi a, pi b) &#123;return a.x &gt; b.x;&#125;&#125;;typedef pair&lt;int,int&gt; pi;priority_queue&lt;pi,vector&lt;pi&gt;,cmp&gt; heap;</code></pre><p>include<sstream>的stringstream用法：</sstream></p><pre class="language-c++" data-language="c++"><code class="language-c++">getline(cin, line);string str &#x3D; &quot;hello world I am very happy!&quot;;stringstream sstream(str);                                              while (sstream) &#123;string substr;sstream &gt;&gt; substr;cout &lt;&lt; substr &lt;&lt; endl;&#125;输出：helloworldIamveryhappy!</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图论</title>
      <link href="/2024/07/27/tu-lun/"/>
      <url>/2024/07/27/tu-lun/</url>
      
        <content type="html"><![CDATA[<h4 id="建图-链式前向星"><a href="#建图-链式前向星" class="headerlink" title="建图(链式前向星)"></a>建图(链式前向星)</h4><pre class="language-c++" data-language="c++"><code class="language-c++">int h[N],e[N], en[N];&#x2F;&#x2F;这里的en一般写成neint idx;int w[N];void add(int a, int b, int c)&#123;e[idx] &#x3D; b;en[idx] &#x3D; h[a];w[idx] &#x3D; c;h[a] &#x3D; idx++;&#125;</code></pre><h4 id="寻找距离r点最远的距离"><a href="#寻找距离r点最远的距离" class="headerlink" title="寻找距离r点最远的距离"></a>寻找距离r点最远的距离</h4><pre class="language-c++" data-language="c++"><code class="language-c++">void dfs(int r,int l)&#123;for (int i &#x3D; h[r]; i !&#x3D; -1; i &#x3D; en[i])&#x2F;&#x2F;遍历r的所有临边&#123;int q &#x3D; e[i];if (!st[q])&#123;st[q] &#x3D; true;int co &#x3D; w[i];if (l + co &gt; maxx)&#123;far &#x3D; q;maxx &#x3D; l + co;&#125;dfs(q, l + co);&#125;&#125;&#125;</code></pre><h4 id="二分图判断"><a href="#二分图判断" class="headerlink" title="二分图判断"></a>二分图判断</h4><p>当且仅当图中没有奇数环，在所有连通块中，将随机一个点染色，然后dfs遍历连通块，和这个点相连的点染其他颜色，如果颜色相同，那么失败</p><pre class="language-c++" data-language="c++"><code class="language-c++">bool check&#x3D;true;for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;if (!color[i]) &#123;      dfs(i, 1);&#125;&#125;void dfs(int a, int b) &#123;color[a] &#x3D; b;for (int i &#x3D; h[a]; ~i; i &#x3D; ne[i]) &#123;if (!color[e[i]]) &#123;dfs(e[i], 3 - b);&#x2F;&#x2F;1和2是不同的颜色&#125; else if (color[e[i]] &#x3D;&#x3D; b) &#123;check &#x3D; false;return;&#125;&#125;&#125;</code></pre><h4 id="树遍历"><a href="#树遍历" class="headerlink" title="树遍历"></a>树遍历</h4><p>前序遍历：根左右<br>中序遍历：左根右<br>后序遍历：左右根<br>根据前中遍历求得后续遍历（存在ans），当无法找到根节点时表示无法完成,根据build的顺序可以决定存储结果是前中后序列遍历</p><pre class="language-c++" data-language="c++"><code class="language-c++">void build1(int ql, int qr, int zl, int zr) &#123;int root &#x3D; qianxu[ql];int k &#x3D; -1;for (int i &#x3D; zl; i &lt;&#x3D; zr; i++) &#123;if (zhongxu[i] &#x3D;&#x3D; root) &#123;k &#x3D; i;break;&#125;&#125;if (k &#x3D;&#x3D; -1) &#123;st &#x3D; false;return;&#125; else &#123;int llen &#x3D; k - zl;int rlen &#x3D; zr - k;if (llen &gt; 0) &#123;build1(ql + 1, ql + llen, zl, k - 1);&#x2F;&#x2F;遍历左子树&#125;if (rlen &gt; 0) &#123;build1(qr - rlen + 1, qr, k + 1, zr);&#x2F;&#x2F;遍历右子树&#125;&#125;ans.push_back(root);&#x2F;&#x2F;遍历根&#125;&#x2F;&#x2F;结论：对于任何给定的完全二叉树结点数量，都可以通过数组直接给定，结点数量就是数组长度</code></pre><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><p>遍历n次，每次取出距离连通块最近的没有标记过的点，然后标记该点，通过该点的临边更新其他边，返回最小生成树边总长度。</p><pre class="language-c++" data-language="c++"><code class="language-c++">int prim() &#123;int ans &#x3D; 0;        memset(st,0,sizeof(st));memset(dist, 0x3f, sizeof(dist));dist[1] &#x3D; 0;for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;int t &#x3D; -1;for (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;if (!st[j] &amp;&amp; (t &#x3D;&#x3D; -1 || dist[j] &lt; dist[t]))t &#x3D; j;&#125;st[t] &#x3D; true;ans +&#x3D; dist[t];for (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;dist[j] &#x3D; min(dist[j], an[t][j]);&#125;&#125;return ans;&#125;</code></pre><h4 id="迪杰斯特拉（nlogn）："><a href="#迪杰斯特拉（nlogn）：" class="headerlink" title="迪杰斯特拉（nlogn）："></a>迪杰斯特拉（nlogn）：</h4><p>基本思想：初始化为{0,n},意思为n到n的距离为0，每次取出优先队列中最小的点，也就是可以确定的最短路径和点，根据这个已经确定的点去更新周围的点，但凡是能更新的，都加入优先队列中，st[i]表示第i点是否已经被确认最短路径了，而且最开始n刚加进去的时候还没有被确认，所以一开始别把n认定为确定的点了。</p><pre class="language-c++" data-language="c++"><code class="language-c++">#define x first#define y secondtypedef pair&lt;int, int&gt; pi;void djs(int n)&#123;memset(dist, 0x3f, sizeof(dist));        memset(st,false,sizeof(st));priority_queue&lt;pi, vector&lt;pi&gt;, greater&lt;pi&gt;&gt; heap;dist[n] &#x3D; 0;heap.push(&#123; 0,n &#125;);while (heap.size())&#123;auto p &#x3D; heap.top();heap.pop();if (st[p.y])continue;st[p.y] &#x3D; true;for (int u &#x3D; h[p.y];u !&#x3D; -1; u &#x3D; ne[u])&#123;int a &#x3D; e[u];&#x2F;&#x2F;这个点int dis &#x3D; w[u];if (dist[a] &gt; dist[p.y] + dis)&#123;dist[a] &#x3D; dist[p.y] + dis;heap.push(&#123;dist[a],a&#125;);&#125;&#125;&#125;&#125;</code></pre><h4 id="bellman-ford"><a href="#bellman-ford" class="headerlink" title="bellman-ford"></a>bellman-ford</h4><pre class="language-c++" data-language="c++"><code class="language-c++">int dist[510];struct Edge &#123;int a, b, c;&#125;edge[10010];int main()&#123;memset(dist, 0x3f, sizeof(dist));dist[1] &#x3D; 0;int n, m, k;cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;for (int i &#x3D; 1; i &lt;&#x3D; m; i++)&#123;cin &gt;&gt; edge[i].a &gt;&gt; edge[i].b &gt;&gt; edge[i].c;&#125;for (int i &#x3D; 1; i &lt;&#x3D; k; i++)&#123;int distt[510];memcpy(distt,dist,sizeof(dist));for (int j &#x3D; 1; j &lt;&#x3D; m; j++)&#123;int to &#x3D; edge[j].b;int pp &#x3D; edge[j].a;dist[to] &#x3D; min(dist[to], distt[pp] + edge[j].c);&#125;&#125;if (dist[n] &gt; 0x3f3f3f3f&#x2F;2)&#x2F;&#x2F;重要，比如说5是无穷大，4是无穷大，4-5是-2，那么5会更新为0x3f3f3f3f-2;cout &lt;&lt; &quot;impossible&quot;;elsecout &lt;&lt; dist[n];return 0;&#125;</code></pre><h4 id="spfa"><a href="#spfa" class="headerlink" title="spfa"></a>spfa</h4><p>bellman-ford的优化版本，对于含负权也可以用，最坏 O(nm)最好O(m),m是边数，n是边数<br>基本思想是：初始加入最初点，st[i]表示i是否在queue中，根据queue里面的点依次更新其他所有相邻点，如果一个点被更新了，那么加入队列，注意出队列时要把st改变。</p><pre class="language-c++" data-language="c++"><code class="language-c++">void spfa() &#123;memset(dist, 0x3f, sizeof(dist));      memset(st,false,sizeof(st));q.push(1);dist[1] &#x3D; 0;st[1] &#x3D; true;while (q.size()) &#123;int a &#x3D; q.front();q.pop();st[a]&#x3D;false;for (int i &#x3D; h[a]; i !&#x3D; -1; i &#x3D; ne[i]) &#123;if (dist[e[i]] &gt; dist[a] + w[i]) &#123;dist[e[i]] &#x3D; dist[a] + w[i];if (!st[e[i]]) &#123;q.push(e[i]);st[e[i]]&#x3D;true;&#125;&#125;&#125;&#125;&#125;</code></pre><h4 id="无向图的最小环（大于等于三个节点）："><a href="#无向图的最小环（大于等于三个节点）：" class="headerlink" title="无向图的最小环（大于等于三个节点）："></a>无向图的最小环（大于等于三个节点）：</h4><p>在floyd的第k层未开始循环前，已经求解了所有i和j之间经过1<del>k-1的最短路径，为了按照环中的最大点来分类，枚举点k的所有临点i和j（i和j均小于k），如果i和j已经可达，那么i和j之间的点也只是1</del>k-1，满足环中最大点为k，此时环的值为k的两个临边和加上i和j的最短路径长度。<br>为了按顺序输出方案，可以把方案定为k<del>i</del>get_path(i,j)~j,这里的get_path是i和j的最短路中所有点（不包括i和j），在floyd循环中可以记录最后一个更新i和j距离的点，记为pos[i][j],那么get_path（i,j）可以用分治法，即get_path（i,j）&#x3D;get_path(i,pos[i][j])+pos[i][j]+get_path(pos[i][j],j),当pos[i][j]&#x3D;&#x3D;0时意味着i和j的最短路不经过其他点，那么按照get_path（i,j）的定义”i和j的最短路中所有点（不包括i和j）“，就可以直接返回了。</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;const int INF &#x3D; 1e9;typedef long long ll;int w[110][110], f[110][110];vector&lt;int&gt; path;int pos[110][110];void get_path(int i, int j) &#123;if (pos[i][j] &#x3D;&#x3D; 0)return;get_path(i, pos[i][j]);path.push_back(pos[i][j]);get_path(pos[i][j], j);&#125;int main(void) &#123;int n, m;cin &gt;&gt; n &gt;&gt; m;memset(w, 0x3f, sizeof(w));for (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;int a, b, c;cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;w[a][b] &#x3D; min(w[a][b], c);w[b][a] &#x3D; min(w[b][a], c);&#125;for (int i &#x3D; 1; i &lt;&#x3D; n; i++)w[i][i] &#x3D; 0;memcpy(f, w, sizeof(w));int ans &#x3D; INF;for (int k &#x3D; 1; k &lt;&#x3D; n; k++) &#123;for (int i &#x3D; 1; i &lt; k; i++) &#123;for (int j &#x3D; i + 1; j &lt; k; j++) &#123;if ((ll)w[i][k] + w[k][j] + f[i][j] &lt; ans) &#123;&#123;ans &#x3D; w[i][k] + w[k][j] + f[i][j];path.clear();path.push_back(k);path.push_back(i);get_path(i, j);path.push_back(j);&#125;&#125;&#125;&#125;for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;for (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;&#123;if (f[i][k] + f[k][j] &lt; f[i][j]) &#123;f[i][j] &#x3D; f[i][k] + f[k][j];pos[i][j] &#x3D; k;&#125;&#125;&#125;&#125;&#125;if(path.size())&#123;    for (auto i : path)cout &lt;&lt; i &lt;&lt; &quot; &quot;;&#125;elsecout&lt;&lt;&quot;No solution.\n&quot;;return 0;&#125;</code></pre><h4 id="最短路计数"><a href="#最短路计数" class="headerlink" title="最短路计数"></a>最短路计数</h4><p>按照djs来求解过程一定是拓扑序。如果f+w&lt;f，那么最短路数量前赋予给后，如果f+w和f相同那么最短路数量后+前</p><pre class="language-c++" data-language="c++"><code class="language-c++">void djs(int a) &#123;memset(st, false, sizeof(st));memset(f, 0x3f, sizeof(f));priority_queue&lt;pi, vector&lt;pi&gt;, greater&lt;pi&gt;&gt; heap;heap.push(&#123;0, a&#125;);f[a] &#x3D; 0;dp[a] &#x3D; 1;while (heap.size()) &#123;pi u &#x3D; heap.top();heap.pop();if (st[u.y])continue;st[u.y] &#x3D; true;for (int i &#x3D; h[u.y]; ~i; i &#x3D; ne[i]) &#123;if (u.x + w[i] &lt; f[e[i]]) &#123;f[e[i]] &#x3D; u.x + w[i];heap.push(&#123;f[e[i]], e[i]&#125;);dp[e[i]] &#x3D; dp[u.y];&#x2F;&#x2F;第一次遇到最短路，覆盖掉最短路&#125; else if (u.x + w[i] &#x3D;&#x3D; f[e[i]]) &#123;dp[e[i]] &#x3D;(dp[e[i]]+ dp[u.y]);&#x2F;&#x2F;相当于dp&#125;&#125;&#125;&#125;</code></pre><h4 id="最短路计数拓展"><a href="#最短路计数拓展" class="headerlink" title="最短路计数拓展"></a>最短路计数拓展</h4><p>求每个点的最短路和次短路数量<br>思路为在djs过程中将每个点分为两部分，f[i][0]是i的最短路长度，f[i][1]是到i的次短路长度，cnt[i][0]是到i的最短路数量，cnt[i][1]是到i的次短路数量。<br>heap中弹出来的为点+状态的二维表示状态，所以判断是否出现也是点+状态的二维表示，f[u][type]+w[i]有四种情况，是被f[k][0],f[k][1]隔开的，分别是小于f[k][0]，类比与树形dp，次小值继承前一个最小值的信息；然后是等于f[k][0]和f[k][1],然后是大于f[k][0]小于f[k][1]，注意每一次更新都需要将更新后的二维状态加入heap数组。</p><pre class="language-c++" data-language="c++"><code class="language-c++">struct node &#123;int dist, u, type;bool operator&gt;(const node a) const &#123;return dist &gt; a.dist;&#125;&#125;;void djs(int s) &#123;memset(f, 0x3f, sizeof(f));memset(st, 0, sizeof(st));memset(cnt, 0, sizeof(cnt));priority_queue&lt;node, vector&lt;node&gt;, greater&lt;node&gt;&gt; heap;heap.push(&#123;0, s, 0&#125;);f[s][0] &#x3D; 0;cnt[s][0] &#x3D; 1;cnt[s][1] &#x3D; 0;while (heap.size()) &#123;node l &#x3D; heap.top();heap.pop();int u &#x3D; l.u, dist &#x3D; l.dist, type &#x3D; l.type;if (st[u][type])continue;st[u][type] &#x3D; true;for (int i &#x3D; h[u]; ~i; i &#x3D; ne[i]) &#123;int k &#x3D; e[i];if (dist + w[i] &lt; f[k][0]) &#123;f[k][1] &#x3D; f[k][0], cnt[k][1] &#x3D; cnt[k][0];heap.push(&#123;f[k][1], k, 1&#125;);f[k][0] &#x3D; dist + w[i], cnt[k][0] &#x3D; cnt[u][type];heap.push(&#123;f[k][0], k, 0&#125;);&#125; else if (dist + w[i] &#x3D;&#x3D; f[k][0])cnt[k][0] +&#x3D; cnt[u][type];else if (dist + w[i] &lt; f[k][1]) &#123;f[k][1] &#x3D; dist + w[i], cnt[k][1] &#x3D; cnt[u][type];heap.push(&#123;f[k][1], k, 1&#125;);&#125; else if (dist + w[i] &#x3D;&#x3D; f[k][1])cnt[k][1] +&#x3D; cnt[u][type];&#125;&#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数学</title>
      <link href="/2024/07/27/shu-xue/"/>
      <url>/2024/07/27/shu-xue/</url>
      
        <content type="html"><![CDATA[<h4 id="vector排序"><a href="#vector排序" class="headerlink" title="vector排序"></a>vector排序</h4><pre class="language-c++" data-language="c++"><code class="language-c++">vector&lt;int &gt;an;sort(an.begin(),an.end());&#x2F;&#x2F;从小到大排列;</code></pre><h4 id="更相减损术"><a href="#更相减损术" class="headerlink" title="更相减损术"></a>更相减损术</h4><p>适用于求：gcd_sub(pow(a,b),pow(a,c))&#x3D;pow(a,gcd(b,c))  </p><pre class="language-c++" data-language="c++"><code class="language-c++">ll gcd_sub(ll a, ll b) &#123;if (a &lt; b)swap(a, b);if (b &#x3D;&#x3D; 1)return a;return gcd_sub(b, a &#x2F; b);&#125;</code></pre><h4 id="三分法"><a href="#三分法" class="headerlink" title="三分法"></a>三分法</h4><p>对于求一个只包含一个波峰或者波谷函数的最值，通过求两个三分点进行比较，更接近目标的是好点，否则是坏点，坏点的那一边往里缩，因为目标和好点一定在坏点的一侧，坏点的那边就不包含最优解了</p><pre class="language-c++" data-language="c++"><code class="language-c++">double left &#x3D; 0, right &#x3D; 1000;double ans &#x3D; 0x3f3f3f3f;while (fabs(right - left) &gt; lp) &#123;double ll &#x3D; left + (right - left) &#x2F; 3;double rr &#x3D; right - (right - left) &#x2F; 3;double rrans &#x3D; 0;double llans &#x3D; 0;for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;rrans &#x3D; max(rrans, a[i] * rr * rr + b[i] * rr + c[i]);&#x2F;&#x2F;求解函数值llans &#x3D; max(llans, a[i] * ll * ll + b[i] * ll + c[i]);&#x2F;&#x2F;求解函数值&#125;ans &#x3D; min(rrans, llans);if (rrans &lt; llans)&#x2F;&#x2F;注意这里的更小值是好点，所以rr是好点，ll那边就要缩left &#x3D; ll;elseright &#x3D; rr;&#125;</code></pre><h4 id="保序离散化"><a href="#保序离散化" class="headerlink" title="保序离散化"></a>保序离散化</h4><p>提前将所有要用到的下标存进alls里面（vector），队alls进行排序+去重，对于要用到的下标根据find函数去寻找，注意在返回时+1，相当于将这些下标映射在1~alls.size()。</p><pre class="language-c++" data-language="c++"><code class="language-c++">sort(alls.begin(), alls.end());&#x2F;&#x2F;排序alls.erase(unique(alls.begin(), alls.end()), alls.end());&#x2F;&#x2F;去重，unique函数返回不重复序列的后一个指针。int find(int a) &#123;int l &#x3D; 0, r &#x3D; alls.size() - 1;while (l &lt; r) &#123;int mid &#x3D; r + l &gt;&gt; 1;if (alls[mid] &lt; a)l &#x3D; mid + 1;elser &#x3D; mid;&#125;return l + 1;&#125;</code></pre><h4 id="非保序离散化"><a href="#非保序离散化" class="headerlink" title="非保序离散化"></a>非保序离散化</h4><p>用unordered_map和递增的idx赋予每一个下标一个独特的值，代码量简单，与alls区别是寻找和离散化过程结合在一起。</p><pre class="language-c++" data-language="c++"><code class="language-c++">int idx&#x3D;0;unordered_map&lt;int,int&gt; res;res.clear();idx&#x3D;0;int find(int a) &#123;if (res.count(a) &#x3D;&#x3D; 0)res[a] &#x3D; ++idx;return res[a];&#125;</code></pre><h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作:"></a>字符串操作:</h4><pre class="language-c++" data-language="c++"><code class="language-c++">string str1(&quot;hello&quot;);cout &lt;&lt; str1 &lt;&lt; endl;&#x2F;&#x2F;hellostring str2(&quot;hello&quot;,2);&#x2F;&#x2F;指定字符串的前2个字符cout &lt;&lt; str2 &lt;&lt; endl;&#x2F;&#x2F;hestring str3(str1, 2);&#x2F;&#x2F;从下标2开始的字符的拷贝cout &lt;&lt; str3 &lt;&lt; endl;&#x2F;&#x2F;llostring str4(str1, 2,2);&#x2F;&#x2F;从下标2开始的2个字符的拷贝cout &lt;&lt; str4 &lt;&lt; endl;&#x2F;&#x2F;ll</code></pre><h4 id="约数个数"><a href="#约数个数" class="headerlink" title="约数个数"></a>约数个数</h4><p>给定 n个正整数 ai，请你输出这些数的乘积的约数个数，答案对 109+7取模<br>假设k&#x3D;a1^p1<em>a2^p2</em>a3^p3<br>那么约数个数为(p1+1)(p2+1)(p3+1)</p><h4 id="约数之和"><a href="#约数之和" class="headerlink" title="约数之和"></a>约数之和</h4><p>假设k&#x3D;a1^p1<em>a2^p2</em>a3^p3<br>约数和为(pow(a1,0)+pow(a1,1)+….pow(a1,p1)(pow(a2,0)+pow(a2,1)+….pow(a2,p2))(pow(a3,0)+pow(a3,1)+….pow(a3,p3))</p><h4 id="欧几里得"><a href="#欧几里得" class="headerlink" title="欧几里得"></a>欧几里得</h4><p>返回的是a和b的最大公约数</p><pre class="language-c++" data-language="c++"><code class="language-c++">int gcd(int a, int b)&#123;return b ? gcd(b, a % b) : a;&#125;</code></pre><h4 id="拓展欧几里得"><a href="#拓展欧几里得" class="headerlink" title="拓展欧几里得"></a>拓展欧几里得</h4><p>适用于ax+by&#x3D;gcd(a,b)  通解为x0+z*(b&#x2F;p)   y0-z*(a&#x2F;p) z为任意整数 如果右边不是gcd(a,b) 则必须整除gcd(a,b)才有解，并且x0和y0要相应的改变</p><pre class="language-c++" data-language="c++"><code class="language-c++">int exgcd(int a, int b, int&amp; x, int&amp; y)&#123;if (!b)&#123;x &#x3D; 1;y &#x3D; 0;return;&#125;exgcd(b, a % b, y, x);y &#x3D; y - a &#x2F; b * x;&#125;</code></pre><h4 id="筛质数（n）"><a href="#筛质数（n）" class="headerlink" title="筛质数（n）:"></a>筛质数（n）:</h4><pre class="language-c++" data-language="c++"><code class="language-c++">bool st[100001000];vector&lt;int&gt; res;void get_prime(int n)&#123;for (int a &#x3D; 2; a &lt;&#x3D; n; a++)&#123;if (!st[a])&#123;res.push_back(a);&#125;for (int j &#x3D; 0; res[j]*a &lt;&#x3D; n; j++)&#123;st[a * res[j]] &#x3D; true;if (a % res[j] &#x3D;&#x3D; 0)break;&#125;&#125;&#125;</code></pre><h4 id="分解质因数（logn）"><a href="#分解质因数（logn）" class="headerlink" title="分解质因数（logn）:"></a>分解质因数（logn）:</h4><pre class="language-c++" data-language="c++"><code class="language-c++">unordered_map&lt;int, int&gt; res;void help(int a)&#123;for (int i &#x3D; 2; i &lt;&#x3D; sqrt(a); i++)&#123;while (a % i &#x3D;&#x3D; 0)&#123;res[i]++;a &#x3D; a &#x2F; i;&#125;&#125;if (a &gt; 1)res[a]++;&#125;</code></pre><h4 id="秦九韶算法"><a href="#秦九韶算法" class="headerlink" title="秦九韶算法"></a>秦九韶算法</h4><p>针对a0pow(p,0)+a1pow(p,1)+a2pow(p,2)+….anpow(p,n);</p><pre class="language-c++" data-language="c++"><code class="language-c++">long long int o&#x3D;an;for(int i&#x3D;n-1;i&gt;&#x3D;0;i--)o &#x3D; (o * p + a[i]) % mod;</code></pre><h4 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h4><p>（要理解本质，a<em>b的矩阵与b</em>c的矩阵相乘结果为a*c的数组，遍历顺序是a到c到b）</p><pre class="language-c++" data-language="c++"><code class="language-c++">void mul(ll an[][6], ll bn[][6],ll cn[][6])&#123;ll temp[6][6];memset(temp, 0, sizeof(temp));for (int i &#x3D; 0; i &lt; 6; i++)&#123;for (int j &#x3D; 0; j &lt; 6; j++)&#123;for (int z &#x3D; 0; z &lt; 6; z++)&#123;temp[i][j] &#x3D;(temp[i][j]+ an[i][z] * bn[z][j] % N)%N;&#125;&#125;&#125;memcpy(cn, temp, sizeof(temp));&#125;void quickmi(ll an[6][6], ll p)&#123;ll res[6][6];memset(res, 0, sizeof(res));for (int i &#x3D; 0; i &lt; 6; i++)&#123;res[i][i] &#x3D; 1;&#125;while (p &gt; 1)&#123;if (p &amp; 1)&#123;mul(res, an,res);p--;&#125;p &#x3D; p &#x2F; 2;mul(an, an,an);&#125;mul(res, an,res);memcpy(an, res, sizeof(res));&#125;</code></pre><h4 id="1到n的所有数的约数-nlogn"><a href="#1到n的所有数的约数-nlogn" class="headerlink" title="1到n的所有数的约数(nlogn)"></a>1到n的所有数的约数(nlogn)</h4><pre class="language-c++" data-language="c++"><code class="language-c++">for (int i &#x3D; 1; i &lt; n; i++) &#123;for (int j &#x3D; i; j &lt; n; j &#x3D; j + i) &#123;yueshu[j].push_back(i);&#125;&#125;</code></pre><h4 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h4><pre class="language-c++" data-language="c++"><code class="language-c++">int an[100010];int bn[100010];int main()&#123;int n, m;cin &gt;&gt; n &gt;&gt; m;for (int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;cin &gt;&gt; an[i];&#125;bn[1] &#x3D; an[1];for (int i &#x3D; 2; i &lt;&#x3D; n; i++)&#x2F;&#x2F;前缀和的逆向使用，an是bn的前缀和，由an得到bn，这样一次性操作an中k个数字同时增加减少，只需要对bn中两个数字进行操作即可&#123;bn[i] &#x3D; an[i] - an[i - 1];&#125;while (m--)&#123;int l, r, c;cin &gt;&gt; l &gt;&gt; r &gt;&gt; c;bn[l] +&#x3D; c;if (r &lt; n)bn[r + 1] -&#x3D; c;&#125;an[1] &#x3D; bn[1];for (int i &#x3D; 2; i &lt;&#x3D; n; i++)&#123;an[i] &#x3D;an[i-1]+bn[i];&#125;for (int i &#x3D; 1; i &lt;&#x3D; n; i++)&#123;cout &lt;&lt; an[i] &lt;&lt; &quot; &quot;;&#125;return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2024/07/27/shu-ju-jie-gou/"/>
      <url>/2024/07/27/shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<h4 id="trie字典树"><a href="#trie字典树" class="headerlink" title="trie字典树"></a>trie字典树</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;cnt是总共出现的点的个数，如果是字符串字典树，那么就是所有字符的数量int son[N][27], idx, cnt[N];&#x2F;&#x2F;插入这个字符串void insert(string a) &#123;int p &#x3D; 0;for (int i &#x3D; 0; a[i]; i++) &#123;int u &#x3D; a[i] - &#39;a&#39;;if (!son[p][u])son[p][u] &#x3D; ++idx;p &#x3D; son[p][u];&#125;cnt[p]++;&#125;&#x2F;&#x2F;返回这个字符串之前出现的次数int query(string a) &#123;int p &#x3D; 0;for (int i &#x3D; 0; a[i]; i++) &#123;int u &#x3D; a[i] - &#39;a&#39;;if (!son[p][u]) &#123;return 0;&#125;p &#x3D; son[p][u];&#125;return cnt[p];&#125;</code></pre><h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;初始化：for (int i &#x3D; 1; i &lt;&#x3D; n; i++) p[i] &#x3D; i;&#x2F;&#x2F;查找：int find(int a) &#123;if (p[a] !&#x3D; a)p[a] &#x3D; find(p[a]);return p[a];&#125;&#x2F;&#x2F;添加a与b：p(find(a))&#x3D;find(b);</code></pre><h4 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h4><p>其基本用法是动态的在1~n这些数字中加减后，仍然可以快速求得前缀和。</p><pre class="language-c++" data-language="c++"><code class="language-c++">int n, m;ll tr[N];ll lowbit(ll a) &#123;return a &amp; (-a);&#125;&#x2F;&#x2F;表示an[a]+&#x3D;k;void add(ll a,ll k) &#123;for (int i &#x3D; a; i &lt;&#x3D; n; i +&#x3D; lowbit(i)) &#123;tr[i] +&#x3D; k;&#125;&#125;&#x2F;&#x2F;注意i&gt;0,数字的下标也是从0开始的。ask(a)返回前a个数的和ll ask(ll a) &#123;ll sum &#x3D; 0;for (int i &#x3D; a; i; i -&#x3D; lowbit(i)) &#123;sum +&#x3D; tr[i];&#125;return sum;&#125;</code></pre><h4 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h4><pre class="language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;建树操作，初始调用为build(1,1,n);注意u是根节点编号void build(int u, int l, int r) &#123;tr[u] &#x3D; &#123;l, r&#125;;if (l &#x3D;&#x3D; r)return;int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;build(u &lt;&lt; 1, l, mid);build(u &lt;&lt; 1 | 1, mid + 1, r);        pushup(u);&#125;&#x2F;&#x2F;修改操作，调用为modify(1,a,v)，将a这个点的值改为v,注意pushup是在更新了子节点后，用子节点的信息来更新自身节点，非常重要,注意u是根节点编号。void modify(int u, int l,int r, int v) &#123;if (tr[u].l &gt;&#x3D; l &amp;&amp; tr[u].r &lt;&#x3D; r)tr[u].v &#x3D; v;else &#123;                pushdown(u);int mid &#x3D; tr[u].r + tr[u].l &gt;&gt; 1;if (l &lt;&#x3D; mid)modify(u &lt;&lt; 1, l,r, v);if(r&gt;mid)modify(u &lt;&lt; 1 | 1, l,r, v);pushup(u);&#125;&#125;&#x2F;&#x2F;查询操作:调用为query(1,l,r)，在l和r这个区间内寻找答案，注意u是根节点编号int query(int u, int l, int r) &#123;if (l &lt;&#x3D; tr[u].l &amp;&amp; r &gt;&#x3D; tr[u].r)return tr[u].v;        pushdown(u);int ans &#x3D; 0;int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;if (l &lt;&#x3D; mid)ans &#x3D; max(ans, query(u &lt;&lt; 1, l, r));if (r &gt; mid)ans &#x3D; max(ans, query(u &lt;&lt; 1 | 1, l, r));return ans;&#125;&#x2F;&#x2F;或者：node query(int u, int l, int r) &#123;if (tr[u].l &gt;&#x3D; l &amp;&amp; tr[u].r &lt;&#x3D; r) &#123;return tr[u];&#125; else &#123;pushdown(u);int mid &#x3D; tr[u].l + tr[u].r &gt;&gt; 1;if (r &lt;&#x3D; mid)return query(u &lt;&lt; 1, l, r);if (l &gt; mid)return query(u &lt;&lt; 1 | 1, l, r);node res;auto ll &#x3D; query(u &lt;&lt; 1, l, r);auto rr &#x3D; query(u &lt;&lt; 1 | 1, l, r);pushup(res, ll, rr);return res;&#125;&#125;&#x2F;&#x2F;pushup操作：用子节点的信息来更新自身节点，每道题有独特的写法void pushup(int u) &#123;tr[u].v &#x3D; max(tr[u &lt;&lt; 1].v, tr[u &lt;&lt; 1 | 1].v);&#125;void pushdown(int u)&#123;                tr[u].add&#x3D;0;&#125;</code></pre><h4 id="线段树经典题"><a href="#线段树经典题" class="headerlink" title="线段树经典题"></a>线段树经典题</h4><p>区间修改和求区间gcd。<br>前提知识：gcd(a,b,c,d)&#x3D;gcd(a,b-a,c-b,d-c);&#x2F;&#x2F;注意到除了第一项，后面都可以转化成差分的形式，例如gcd(2,6,12)&#x3D;gcd(2,4,6)，但要注意gcd要取绝对值，因为差分可能存在负数，但绝对值一定是对的，<br>gcd(a,b,c,d)&#x3D;gcd(gcd(a,b),gcd(c,d))是这道题的核心思想<br>所以可以维护一个原数组的差分数组线段树，要求l<del>r的gcd,先在树中求l</del>1-r的gcd，然后求an[l],这里相当于求差分数组的1~l的和，用线段树去查找。</p><pre class="language-c++" data-language="c++"><code class="language-c++">int n, m;typedef long long ll;ll an[500010];ll sn[500010];struct Node &#123;ll l, r;ll sum, d;&#125; tr[500010 * 4];ll gcd(ll a, ll b) &#123;return b ? gcd(b, a % b) : a;&#125;void pushup(Node &amp;u, Node &amp;l, Node &amp;r) &#123;u.sum &#x3D; l.sum + r.sum;u.d &#x3D; gcd(l.d, r.d);&#125;void pushup(int u) &#123;pushup(tr[u], tr[u &lt;&lt; 1], tr[u &lt;&lt; 1 | 1]);&#125;build(1, 1, n);while (m--) &#123;char a;cin &gt;&gt; a;if (a &#x3D;&#x3D; &#39;Q&#39;) &#123;int l, r;cin &gt;&gt; l &gt;&gt; r;ll c &#x3D; query(1, 1, l).sum;if (l &#x3D;&#x3D; r)cout &lt;&lt; c&lt;&lt;&quot;\n&quot;;else &#123;ll d &#x3D; query(1, l + 1, r).d;cout &lt;&lt; abs(gcd(c, d)) &lt;&lt; &quot;\n&quot;;&#125;&#125; else &#123;ll l, r, d;cin &gt;&gt; l &gt;&gt; r &gt;&gt; d;modify(1, l, d);if (r + 1 &lt;&#x3D; n)modify(1, r + 1, -d);&#125;&#125;return 0;&#125;</code></pre><h4 id="主席树"><a href="#主席树" class="headerlink" title="主席树"></a>主席树</h4><p>用于在静态的数组中，动态寻找子区间第k小的数。<br>主席树本质上是可持久化权值线段树，前k个数组成的权值线段树可以用前k-1个数组成的线段树作为基础，动态开点。在遍历时，用       r-（l-1）的信息得到，l-r的权值线段树信息。</p><pre class="language-c++" data-language="c++"><code class="language-c++">const int N &#x3D; 100010;int n, m;int a[N];vector&lt;int&gt; nums;struct Node&#123;    int l, r;    int cnt;&#125;tr[N * 4 + N * 17];  &#x2F;&#x2F;N * 4 + NlogNint root[N], idx;int find(int x)&#123;    return lower_bound(nums.begin(), nums.end(), x) - nums.begin();&#125;&#x2F;&#x2F; 对左右边界建立节点并编号, build是建立好骨架, 每个版本insert改不同数据int build (int l, int r)&#123;    int p &#x3D; ++idx;    if (l &#x3D;&#x3D; r) return p;    int mid &#x3D; l + r &gt;&gt; 1;    tr[p].l &#x3D; build(l, mid), tr[p].r &#x3D; build(mid+1, r);    return p;&#125;&#x2F;&#x2F; l, r是要放入的坐标范围, x是要插入的数离散化后的位置int insert(int p, int l, int r, int x)&#123;    &#x2F;&#x2F; 假设现在是从外界第一次执行insert, 那么调用的时候, p必定是根节点,    &#x2F;&#x2F; 那么q就相当于复制了一个根节点, 从节点q进入这棵树的时候, 也能得到之前的所有内容.    &#x2F;&#x2F; 同理, 再往下二分递归的时候, insert会继续复制根节点的左(右)子树, 一直递归直到l&#x3D;&#x3D;r之前,    &#x2F;&#x2F; q和原来的p都是一毛一样. 直到l&#x3D;&#x3D;r才真正插入了新点, 每次插入的时间空间复杂度都是lgk,    &#x2F;&#x2F; 总加起来就是lg1+lg2+...+lgn &#x3D; lg(n!), 根据stirling公式, 结果为nlgn   (大O)    int q &#x3D; ++idx;    tr[q] &#x3D; tr[p];     if (l &#x3D;&#x3D; r)  &#x2F;&#x2F; 如果区间长度为1, 说明就是放这里了    &#123;        &#x2F;&#x2F; tr[q].cnt++是表示插在这个叶节点上        &#x2F;&#x2F; 这个线段树只是保存的每个区间里面的元素个数        &#x2F;&#x2F; 每次插入都只是覆盖到的那堆区间里面的cnt发生+1        tr[q].cnt++;        return q;    &#125;    int mid &#x3D; l + r &gt;&gt; 1;    if (x &lt;&#x3D; mid) tr[q].l &#x3D; insert(tr[p].l, l, mid, x);    else tr[q].r &#x3D; insert(tr[p].r, mid+1, r, x);    tr[q].cnt &#x3D; tr[tr[q].l].cnt + tr[tr[q].r].cnt;  &#x2F;&#x2F; 相当于pushup了    return q;&#125;&#x2F;&#x2F; l ,r是检索范围, q是当前第r个节点root[r]能包含1~r之间所有&#x2F;&#x2F; p的输入是root[l-1], 作用是剔除这个根节点所包含数据的影响int query(int q, int p, int l, int r, int k)&#123;    if (l &#x3D;&#x3D; r) return r; &#x2F;&#x2F; 如果找到位置    &#x2F;&#x2F; 目标是求l r之间的第k小    &#x2F;&#x2F; tr[tr[q].l].cnt - tr[tr[p].l].cnt的结果是求出在p之后插入到q这些数之后,    &#x2F;&#x2F; 有多少个数(cnt)插入了p的左子树, 由于p的内容肯定不能出现在l r之间(p根节点就是root[l-1]),     &#x2F;&#x2F; 所以cnt就是相当于&quot;存在q左子树里面但不存在于1, l 之间的数的个数&quot;    int cnt &#x3D; tr[tr[q].l].cnt - tr[tr[p].l].cnt;     int mid &#x3D; l + r &gt;&gt; 1;    &#x2F;&#x2F; k &lt;&#x3D; cnt说明要找的元素在q的左子树里面, 同时这里面也要剔除掉包含在p左子树的内容    if (k &lt;&#x3D; cnt) return query(tr[q].l, tr[p].l, l, mid, k);    else return query(tr[q].r, tr[p].r, mid+1, r, k - cnt);  &#x2F;&#x2F; 类似同上&#125;int main()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )    &#123;        scanf(&quot;%d&quot;, &amp;a[i]);        nums.push_back(a[i]);  &#x2F;&#x2F;离散化使用    &#125;    &#x2F;&#x2F; 离散化    sort(nums.begin(), nums.end());    nums.erase(unique(nums.begin(), nums.end()), nums.end());    &#x2F;&#x2F; 构造线段树, 构造n个版本的线段树    &#x2F;&#x2F; 第0个版本的什么都没有就用build, build是建立好骨架, 每个版本insert改不同数据    root[0] &#x3D; build(0, nums.size() - 1);    &#x2F;&#x2F; 后面的每插入一个点算一个版本, 每次插入都只是比上一个版本多1个数    &#x2F;&#x2F; 左右参数给0和nums.size()-1是因为离散化之后的值域就是在0, nums.size()-1之间    &#x2F;&#x2F; 要插入必须得把这些地方全包才能保证找得到插入点    for (int i &#x3D; 1; i &lt;&#x3D; n; i++)        root[i] &#x3D; insert(root[i-1], 0, nums.size() - 1, find(a[i]));    while (m -- )    &#123;        int l, r, k;        scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;k);        printf(&quot;%d\n&quot;, nums[query(root[r], root[l-1], 0, nums.size()-1, k)]);    &#125;    return 0;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深度学习实验</title>
      <link href="/2024/07/20/deeplearning1/"/>
      <url>/2024/07/20/deeplearning1/</url>
      
        <content type="html"><![CDATA[<p>使用初始化一个1×3的矩阵M和一个2×1的矩阵N，对两矩阵进行减法操作（要求实现三种不同的形式），给出结果并分析三种方式的不同（如果出现报错，分析报错的原因），同时需要指出在计算过程中发生了什么</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torcha<span class="token operator">=</span>torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>b<span class="token operator">=</span>torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token operator">-</span>b<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span>sub<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>sub<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>  利用创建两个大小分别 3×2 和 4×2的随机数矩阵P和Q，要求服从均值为0，标准差0.01为的正态分布；② 对第二步得到的矩阵Q进行形状变换得到的Q的转置QT; ③对上述得到的矩阵P和矩阵QT求矩阵相乘</p><pre class="language-python" data-language="python"><code class="language-python">P <span class="token operator">=</span> torch<span class="token punctuation">.</span>normal<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0.01</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>Q<span class="token operator">=</span> torch<span class="token punctuation">.</span>normal<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0.01</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>QT <span class="token operator">=</span> torch<span class="token punctuation">.</span>t<span class="token punctuation">(</span>Q<span class="token punctuation">)</span>result <span class="token operator">=</span> torch<span class="token punctuation">.</span>mm<span class="token punctuation">(</span>P<span class="token punctuation">,</span> QT<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>P<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>QT<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span></code></pre><p>给定公式 y3&#x3D;y1+y2&#x3D;x^2+x^3，且 x&#x3D;1。利用学习所得到的Tensor的相关知识，求y3对的x的梯度。要求在计算过程中，在计算x^3时中断梯度的追踪，观察结果并进行原因分析提示, 可使用withtorch.no_grad()， 举例:</p><p>withtorch.no_grad():</p><p>y &#x3D; x *5</p><pre class="language-python" data-language="python"><code class="language-python">x<span class="token operator">=</span>torch<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>requires_grad<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>y1<span class="token operator">=</span>x<span class="token operator">**</span><span class="token number">2</span><span class="token keyword">with</span> torch<span class="token punctuation">.</span>no_grad<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    y2<span class="token operator">=</span>x<span class="token operator">**</span><span class="token number">3</span>y3<span class="token operator">=</span>y1<span class="token operator">+</span>y2y3<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>grad<span class="token punctuation">)</span></code></pre><p>要求动手从0实现 logistic 回归（只借助Tensor和Numpy相关的库）在人工构造的数据集上进行训练和测试（可借助nn.BCELoss或nn.BCEWithLogitsLoss作为损失函数，从零实现二元交叉熵为选作）</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">import</span> torch<span class="token punctuation">.</span>nn <span class="token keyword">as</span> nn<span class="token keyword">import</span> random<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">def</span> <span class="token function">createdata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    n_data <span class="token operator">=</span> torch<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment"># 数据的基本形态</span>    x1 <span class="token operator">=</span> torch<span class="token punctuation">.</span>normal<span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> n_data<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># shape=(50, 2)</span>    y1 <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token comment"># 类型0 shape=(50, 1)</span>    x2 <span class="token operator">=</span> torch<span class="token punctuation">.</span>normal<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span> <span class="token operator">*</span> n_data<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment"># shape=(50, 2)</span>    y2 <span class="token operator">=</span> torch<span class="token punctuation">.</span>ones<span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token comment"># 类型1 shape=(50, 1)</span>    <span class="token comment"># 注意 x, y 数据的数据形式一定要像下面一样 (torch.cat 是合并数据)</span>    x <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">(</span>x1<span class="token punctuation">,</span> x2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span>FloatTensor<span class="token punctuation">)</span>    y <span class="token operator">=</span> torch<span class="token punctuation">.</span>cat<span class="token punctuation">(</span><span class="token punctuation">(</span>y1<span class="token punctuation">,</span> y2<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">(</span>torch<span class="token punctuation">.</span>FloatTensor<span class="token punctuation">)</span>    <span class="token keyword">return</span> x<span class="token punctuation">,</span> y<span class="token keyword">def</span> <span class="token function">data_iter</span><span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> features<span class="token punctuation">,</span> labels<span class="token punctuation">)</span><span class="token punctuation">:</span>    num_examples <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>features<span class="token punctuation">)</span>    indices <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span>num_examples<span class="token punctuation">)</span><span class="token punctuation">)</span>    random<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>indices<span class="token punctuation">)</span>  <span class="token comment"># 样本的读取顺序是随机的     </span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> num_examples<span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span><span class="token punctuation">:</span>        j <span class="token operator">=</span> torch<span class="token punctuation">.</span>LongTensor<span class="token punctuation">(</span>indices<span class="token punctuation">[</span>i<span class="token punctuation">:</span> <span class="token builtin">min</span><span class="token punctuation">(</span>i <span class="token operator">+</span> batch_size<span class="token punctuation">,</span> num_examples<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment"># 最后一次可能不足一个batch         </span>        <span class="token keyword">yield</span>  features<span class="token punctuation">.</span>index_select<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">,</span> labels<span class="token punctuation">.</span>index_select<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">myLogistic</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> w<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> torch<span class="token punctuation">.</span>exp<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">*</span> torch<span class="token punctuation">.</span>mm<span class="token punctuation">(</span>x<span class="token punctuation">,</span>w<span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># 定义二分类交叉熵损失函数</span><span class="token keyword">def</span> <span class="token function">binary_cross_entropy</span><span class="token punctuation">(</span>y_pred<span class="token punctuation">,</span> y_true<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 防止梯度爆炸</span>    epsilon <span class="token operator">=</span> <span class="token number">1e-7</span>    <span class="token comment"># 计算损失</span>    loss <span class="token operator">=</span> <span class="token operator">-</span>torch<span class="token punctuation">.</span>mean<span class="token punctuation">(</span>y_true <span class="token operator">*</span> torch<span class="token punctuation">.</span>log<span class="token punctuation">(</span>y_pred <span class="token operator">+</span> epsilon<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> y_true<span class="token punctuation">)</span> <span class="token operator">*</span> torch<span class="token punctuation">.</span>log<span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> y_pred <span class="token operator">+</span> epsilon<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> loss<span class="token keyword">def</span> <span class="token function">squared_loss</span><span class="token punctuation">(</span>y_hat<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>     <span class="token keyword">return</span> <span class="token punctuation">(</span>y_hat <span class="token operator">-</span> y<span class="token punctuation">.</span>view<span class="token punctuation">(</span>y_hat<span class="token punctuation">.</span>size<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">**</span> <span class="token number">2</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token keyword">def</span> <span class="token function">sgd</span><span class="token punctuation">(</span>params<span class="token punctuation">,</span> lr<span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> param <span class="token keyword">in</span> params<span class="token punctuation">:</span>        param<span class="token punctuation">.</span>data <span class="token operator">-=</span> lr <span class="token operator">*</span> param<span class="token punctuation">.</span>grad <span class="token operator">/</span> batch_sizefeatures<span class="token punctuation">,</span>labels<span class="token operator">=</span>createdata<span class="token punctuation">(</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>features<span class="token punctuation">.</span>data<span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> features<span class="token punctuation">.</span>data<span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token operator">=</span>labels<span class="token punctuation">.</span>data<span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span> lw<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>  cmap<span class="token operator">=</span><span class="token string">'RdYlGn'</span><span class="token punctuation">)</span> plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>num_inputs <span class="token operator">=</span> <span class="token number">2</span>lr <span class="token operator">=</span> <span class="token number">0.01</span>num_epochs <span class="token operator">=</span> <span class="token number">20</span>batch_size <span class="token operator">=</span> <span class="token number">10</span>net <span class="token operator">=</span> myLogisticloss <span class="token operator">=</span> binary_cross_entropyw <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>normal<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0.01</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>num_inputs<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>b <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>w<span class="token punctuation">.</span>requires_grad_<span class="token punctuation">(</span>requires_grad<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>b<span class="token punctuation">.</span>requires_grad_<span class="token punctuation">(</span>requires_grad<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>train_all_loss <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> epoch <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_epochs<span class="token punctuation">)</span><span class="token punctuation">:</span>       <span class="token comment"># 训练模型一共需要num_epochs个迭代周期     # 在每一个迭代周期中，会使用训练数据集中所有样本一次</span>    <span class="token keyword">for</span> X<span class="token punctuation">,</span> y <span class="token keyword">in</span> data_iter<span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> features<span class="token punctuation">,</span> labels<span class="token punctuation">)</span><span class="token punctuation">:</span>       <span class="token comment"># x和y分别是小批量样本的特征和标签</span>        l <span class="token operator">=</span> loss<span class="token punctuation">(</span>net<span class="token punctuation">(</span>X<span class="token punctuation">,</span> w<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment"># l是有关小批量X和y的损失         </span>        l<span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment"># 小批量的损失对模型参数求梯度</span>        sgd<span class="token punctuation">(</span><span class="token punctuation">[</span>w<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">,</span> lr<span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span>     <span class="token comment"># 使用小批量随机梯度下降迭代模型参数         </span>        w<span class="token punctuation">.</span>grad<span class="token punctuation">.</span>data<span class="token punctuation">.</span>zero_<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 梯度清零         </span>        b<span class="token punctuation">.</span>grad<span class="token punctuation">.</span>data<span class="token punctuation">.</span>zero_<span class="token punctuation">(</span><span class="token punctuation">)</span>    labels_pred <span class="token operator">=</span> net<span class="token punctuation">(</span>features<span class="token punctuation">,</span> w<span class="token punctuation">,</span> b<span class="token punctuation">)</span>    train_l <span class="token operator">=</span> loss<span class="token punctuation">(</span>labels_pred<span class="token punctuation">,</span> labels<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    train_all_loss<span class="token punctuation">.</span>append<span class="token punctuation">(</span>train_l<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    labels_pred <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>labels_pred<span class="token operator">></span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>    acc <span class="token operator">=</span> <span class="token punctuation">(</span>labels_pred<span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> labels<span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">100</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'epoch: %d loss:%.5f acc: %.3f'</span><span class="token operator">%</span><span class="token punctuation">(</span>epoch<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>train_l<span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> acc<span class="token punctuation">)</span><span class="token punctuation">)</span>test_data<span class="token punctuation">,</span>test_labels<span class="token operator">=</span> createdata<span class="token punctuation">(</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>scatter<span class="token punctuation">(</span>test_data<span class="token punctuation">.</span>data<span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> test_data<span class="token punctuation">.</span>data<span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token operator">=</span>test_labels<span class="token punctuation">.</span>data<span class="token punctuation">.</span>numpy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> s<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">,</span> lw<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>  cmap<span class="token operator">=</span><span class="token string">'RdYlGn'</span><span class="token punctuation">)</span> plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">with</span> torch<span class="token punctuation">.</span>no_grad<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    labels_pred_test <span class="token operator">=</span> net<span class="token punctuation">(</span>test_data<span class="token punctuation">,</span>w<span class="token punctuation">,</span>b<span class="token punctuation">)</span>    test_l <span class="token operator">=</span>  binary_cross_entropy<span class="token punctuation">(</span>labels_pred_test<span class="token punctuation">,</span> test_labels<span class="token punctuation">.</span>view<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    labels_pred_test <span class="token operator">=</span> torch<span class="token punctuation">.</span>tensor<span class="token punctuation">(</span>np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>labels_pred_test<span class="token operator">></span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>dtype<span class="token operator">=</span>torch<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>    acc_test <span class="token operator">=</span> <span class="token punctuation">(</span>labels_pred_test<span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> test_labels<span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>item<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">100</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'Test_loss: %.5f Test_acc: %.3f'</span><span class="token operator">%</span><span class="token punctuation">(</span>test_l<span class="token punctuation">,</span> acc_test<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p> 要求动手从0实现 softmax 回归（只借助Tensor和Numpy相关的库）在Fashion-MNIST数据集上进行训练和测试，并从loss、训练集以及测试集上的准确率等多个角度对结果进行分析（要求从零实现交叉熵损失函数）</p><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> torch<span class="token keyword">from</span> IPython <span class="token keyword">import</span> display<span class="token keyword">from</span> d2l <span class="token keyword">import</span> torch <span class="token keyword">as</span> d2l<span class="token keyword">from</span> torchvision <span class="token keyword">import</span> transforms<span class="token keyword">import</span> torchvision<span class="token keyword">from</span> torch<span class="token punctuation">.</span>utils <span class="token keyword">import</span> databatch_size <span class="token operator">=</span> <span class="token number">256</span><span class="token keyword">def</span> <span class="token function">load_data_fashion_mnist</span><span class="token punctuation">(</span>batch_size<span class="token punctuation">,</span> resize<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>    <span class="token triple-quoted-string string">"""下载Fashion-MNIST数据集,然后将其加载到内存中"""</span>    trans <span class="token operator">=</span> <span class="token punctuation">[</span>transforms<span class="token punctuation">.</span>ToTensor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">if</span> resize<span class="token punctuation">:</span>        trans<span class="token punctuation">.</span>insert<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> transforms<span class="token punctuation">.</span>Resize<span class="token punctuation">(</span>resize<span class="token punctuation">)</span><span class="token punctuation">)</span>    trans <span class="token operator">=</span> transforms<span class="token punctuation">.</span>Compose<span class="token punctuation">(</span>trans<span class="token punctuation">)</span>    mnist_train <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>FashionMNIST<span class="token punctuation">(</span>        root<span class="token operator">=</span><span class="token string">"../data"</span><span class="token punctuation">,</span> train<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> transform<span class="token operator">=</span>trans<span class="token punctuation">,</span> download<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    mnist_test <span class="token operator">=</span> torchvision<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>FashionMNIST<span class="token punctuation">(</span>        root<span class="token operator">=</span><span class="token string">"../data"</span><span class="token punctuation">,</span> train<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> transform<span class="token operator">=</span>trans<span class="token punctuation">,</span> download<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>mnist_train<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> shuffle<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span>                            num_workers<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            data<span class="token punctuation">.</span>DataLoader<span class="token punctuation">(</span>mnist_test<span class="token punctuation">,</span> batch_size<span class="token punctuation">,</span> shuffle<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span>                            num_workers<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>train_iter<span class="token punctuation">,</span> test_iter <span class="token operator">=</span> load_data_fashion_mnist<span class="token punctuation">(</span>batch_size<span class="token punctuation">)</span>num_inputs <span class="token operator">=</span> <span class="token number">784</span>num_outputs <span class="token operator">=</span> <span class="token number">10</span>W <span class="token operator">=</span> torch<span class="token punctuation">.</span>normal<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0.01</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token punctuation">(</span>num_inputs<span class="token punctuation">,</span> num_outputs<span class="token punctuation">)</span><span class="token punctuation">,</span> requires_grad<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>b <span class="token operator">=</span> torch<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span>num_outputs<span class="token punctuation">,</span> requires_grad<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">softmax</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">:</span>    X_exp <span class="token operator">=</span> torch<span class="token punctuation">.</span>exp<span class="token punctuation">(</span>X<span class="token punctuation">)</span>    partition <span class="token operator">=</span> X_exp<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> keepdim<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> X_exp <span class="token operator">/</span> partition  <span class="token comment"># 这里应用了广播机制</span><span class="token keyword">def</span> <span class="token function">net</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> softmax<span class="token punctuation">(</span>torch<span class="token punctuation">.</span>matmul<span class="token punctuation">(</span>X<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> W<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> W<span class="token punctuation">)</span> <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">cross_entropy</span><span class="token punctuation">(</span>y_hat<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token operator">-</span> torch<span class="token punctuation">.</span>log<span class="token punctuation">(</span>y_hat<span class="token punctuation">[</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>y_hat<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">accuracy</span><span class="token punctuation">(</span>y_hat<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""计算预测正确的数量"""</span>    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>y_hat<span class="token punctuation">.</span>shape<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span> <span class="token keyword">and</span> y_hat<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">:</span>        y_hat <span class="token operator">=</span> y_hat<span class="token punctuation">.</span>argmax<span class="token punctuation">(</span>axis<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token builtin">cmp</span> <span class="token operator">=</span> y_hat<span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span> <span class="token operator">==</span> y    <span class="token keyword">return</span> <span class="token builtin">float</span><span class="token punctuation">(</span><span class="token builtin">cmp</span><span class="token punctuation">.</span><span class="token builtin">type</span><span class="token punctuation">(</span>y<span class="token punctuation">.</span>dtype<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Accumulator</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>    <span class="token triple-quoted-string string">"""在n个变量上累加"""</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0.0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n    <span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token punctuation">[</span>a <span class="token operator">+</span> <span class="token builtin">float</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token keyword">for</span> a<span class="token punctuation">,</span> b <span class="token keyword">in</span> <span class="token builtin">zip</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">reset</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0.0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>data<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__getitem__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> idx<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">evaluate_accuracy</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> data_iter<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>    <span class="token triple-quoted-string string">"""计算在指定数据集上模型的精度"""</span>    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>        net<span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 将模型设置为评估模式</span>    metric <span class="token operator">=</span> Accumulator<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment"># 正确预测数、预测总数</span>    <span class="token keyword">with</span> torch<span class="token punctuation">.</span>no_grad<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> X<span class="token punctuation">,</span> y <span class="token keyword">in</span> data_iter<span class="token punctuation">:</span>            metric<span class="token punctuation">.</span>add<span class="token punctuation">(</span>accuracy<span class="token punctuation">(</span>net<span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">.</span>numel<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> metric<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">/</span> metric<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">train_epoch_ch3</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> train_iter<span class="token punctuation">,</span> loss<span class="token punctuation">,</span> updater<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>    <span class="token triple-quoted-string string">"""训练模型一个迭代周期"""</span>    <span class="token comment"># 将模型设置为训练模式</span>    <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> torch<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>Module<span class="token punctuation">)</span><span class="token punctuation">:</span>        net<span class="token punctuation">.</span>train<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 训练损失总和、训练准确度总和、样本数</span>    metric <span class="token operator">=</span> Accumulator<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> X<span class="token punctuation">,</span> y <span class="token keyword">in</span> train_iter<span class="token punctuation">:</span>        <span class="token comment"># 计算梯度并更新参数</span>        y_hat <span class="token operator">=</span> net<span class="token punctuation">(</span>X<span class="token punctuation">)</span>        l <span class="token operator">=</span> loss<span class="token punctuation">(</span>y_hat<span class="token punctuation">,</span> y<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token builtin">isinstance</span><span class="token punctuation">(</span>updater<span class="token punctuation">,</span> torch<span class="token punctuation">.</span>optim<span class="token punctuation">.</span>Optimizer<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 使用PyTorch内置的优化器和损失函数</span>            updater<span class="token punctuation">.</span>zero_grad<span class="token punctuation">(</span><span class="token punctuation">)</span>            l<span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>            updater<span class="token punctuation">.</span>step<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># 使用定制的优化器和损失函数</span>            l<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>backward<span class="token punctuation">(</span><span class="token punctuation">)</span>            updater<span class="token punctuation">(</span>X<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        metric<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token builtin">float</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> accuracy<span class="token punctuation">(</span>y_hat<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">.</span>numel<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 返回训练损失和训练精度</span>    <span class="token keyword">return</span> metric<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">/</span> metric<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> metric<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">/</span> metric<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">train_ch3</span><span class="token punctuation">(</span>net<span class="token punctuation">,</span> train_iter<span class="token punctuation">,</span> test_iter<span class="token punctuation">,</span> loss<span class="token punctuation">,</span> num_epochs<span class="token punctuation">,</span> updater<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment">#@save</span>    <span class="token triple-quoted-string string">"""训练模型"""</span>    <span class="token keyword">for</span> epoch <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>num_epochs<span class="token punctuation">)</span><span class="token punctuation">:</span>        train_metrics <span class="token operator">=</span> train_epoch_ch3<span class="token punctuation">(</span>net<span class="token punctuation">,</span> train_iter<span class="token punctuation">,</span> loss<span class="token punctuation">,</span> updater<span class="token punctuation">)</span>        test_acc <span class="token operator">=</span> evaluate_accuracy<span class="token punctuation">(</span>net<span class="token punctuation">,</span> test_iter<span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'epoch </span><span class="token interpolation"><span class="token punctuation">&#123;</span>epoch <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">&#125;</span></span><span class="token string">, '</span></span>            <span class="token string-interpolation"><span class="token string">f'train loss </span><span class="token interpolation"><span class="token punctuation">&#123;</span>train_metrics<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token format-spec">.3f</span><span class="token punctuation">&#125;</span></span><span class="token string">, '</span></span>              <span class="token string-interpolation"><span class="token string">f'train acc </span><span class="token interpolation"><span class="token punctuation">&#123;</span>train_metrics<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token format-spec">.3f</span><span class="token punctuation">&#125;</span></span><span class="token string">, '</span></span>              <span class="token string-interpolation"><span class="token string">f'test acc </span><span class="token interpolation"><span class="token punctuation">&#123;</span>test_acc<span class="token punctuation">:</span><span class="token format-spec">.3f</span><span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>    train_loss<span class="token punctuation">,</span> train_acc <span class="token operator">=</span> train_metrics    <span class="token keyword">assert</span> train_loss <span class="token operator">&lt;</span> <span class="token number">0.5</span><span class="token punctuation">,</span> train_loss    <span class="token keyword">assert</span> train_acc <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token keyword">and</span> train_acc <span class="token operator">></span> <span class="token number">0.7</span><span class="token punctuation">,</span> train_acc    <span class="token keyword">assert</span> test_acc <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token keyword">and</span> test_acc <span class="token operator">></span> <span class="token number">0.7</span><span class="token punctuation">,</span> test_acclr <span class="token operator">=</span> <span class="token number">0.1</span><span class="token keyword">def</span> <span class="token function">updater</span><span class="token punctuation">(</span>batch_size<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> d2l<span class="token punctuation">.</span>sgd<span class="token punctuation">(</span><span class="token punctuation">[</span>W<span class="token punctuation">,</span> b<span class="token punctuation">]</span><span class="token punctuation">,</span> lr<span class="token punctuation">,</span> batch_size<span class="token punctuation">)</span>num_epochs <span class="token operator">=</span> <span class="token number">10</span>train_ch3<span class="token punctuation">(</span>net<span class="token punctuation">,</span> train_iter<span class="token punctuation">,</span> test_iter<span class="token punctuation">,</span> cross_entropy<span class="token punctuation">,</span> num_epochs<span class="token punctuation">,</span> updater<span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RL</title>
      <link href="/2024/06/04/rl/"/>
      <url>/2024/06/04/rl/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是强化学习-强化学习的基本概念"><a href="#什么是强化学习-强化学习的基本概念" class="headerlink" title="什么是强化学习?强化学习的基本概念"></a>什么是强化学习?强化学习的基本概念</h3><p>强化学习是机器学习领域的一类学习问题，它与常见的有监督学习、无监督学习等的最大不同之处在于，它是通过与环境之间的交互和反馈来学习的。正如一个新生的婴儿一样，它通过哭闹、吮吸、爬走等来对环境进行探索，并且慢慢地积累起对于环境的感知，从而一步步学习到环境的特性使得自己的行动能够尽快达成自己的愿望。再比如，这也同我们学习下围棋的模式类似，我们通过和不同的对手一盘一盘得对弈，慢慢积累起来我们对于每一步落子的判断，从而慢慢地提高自身的围棋水平。由DeepMind研发的AlphaGo围棋程序在训练学习的过程中就用到了强化学习的技术。</p><p>下面让我们来正式地定义一下强化学习问题。强化学习的基本模型就是个体-环境的交互。<em><strong>个体&#x2F;智能体</strong></em>（agent）就是能够采取一系列行动并且期望获得较高收益或者达到某一目标的部分，比如我们前面例子中的新生婴儿或者在学习下围棋的玩家。而与此相关的另外的部分我们都统一称作<em><strong>环境</strong></em>（environment），比如前面例子中的婴儿的环境（比如包括其周围的房间以及婴儿的父母等）或者是你面前的棋盘以及对手。整个过程将其离散化为不同的时刻（time step）。在每个时刻环境和个体都会产生相应的交互。个体可以采取一定的<em><strong>行动</strong></em>（action），这样的行动是施加在环境中的。环境在接受到个体的行动之后，会反馈给个体环境目前的<em><strong>状态</strong></em>（state）以及由于上一个行动而产生的<em><strong>奖励</strong></em>（reward）。其中值得注意的一点是，这样个体-环境的划分并不一定是按照实体的临近关系划分，比如在动物行为学上上，动物获得的奖励其实可能来自于其自身大脑中的化学物质的分泌，因此这时动物大脑中实现这一奖励机制的部分，也应该被划分为环境；而个体就仅仅只包括接受信号并且做出决定的部分。</p>]]></content>
      
      
      <categories>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Kafka知识点</title>
      <link href="/2024/05/03/kafka-knowledge/"/>
      <url>/2024/05/03/kafka-knowledge/</url>
      
        <content type="html"><![CDATA[<h1 id="Kafka中Topic、Partition、Groups、Brokers概念辨析"><a href="#Kafka中Topic、Partition、Groups、Brokers概念辨析" class="headerlink" title="Kafka中Topic、Partition、Groups、Brokers概念辨析"></a>Kafka中Topic、Partition、Groups、Brokers概念辨析</h1><h3 id="一、Topic和Partition"><a href="#一、Topic和Partition" class="headerlink" title="一、Topic和Partition"></a>一、Topic和Partition</h3><p>在Kafka中，Topic是一个逻辑概念，用于对数据流进行分类和组织。每个Topic可以包含多个Partition，Partition是物理概念，用于实现数据的高可用性和容错性。每个Partition对应一个或多个副本，副本分为领导者(leader)和追随者(follower)，领导者负责处理读写请求，追随者用于备份数据。如果领导者宕机，某个追随者会被选举为新的领导者。</p><h3 id="二、Groups和Brokers"><a href="#二、Groups和Brokers" class="headerlink" title="二、Groups和Brokers"></a>二、Groups和Brokers</h3><p>Kafka<a href="https://cloud.baidu.com/product/RabbitMQ.html">消息队列</a>有两种消费模式，分别是点对点模式和订阅&#x2F;发布模式。在订阅&#x2F;发布模式下，多个消费者可以组成一个Group来共享一个Topic的消息。消费者在Group中共享负载，共同消费Topic的消息。Brokers是Kafka集群中的实体，每个Broker负责<a href="https://cloud.baidu.com/product/bos.html">存储</a>和管理Topic的Partition副本。Kafka集群将Topic的多个Partition分布在多个Broker上，以提高系统的可靠性和容错性。</p><h3 id="三、实例解析"><a href="#三、实例解析" class="headerlink" title="三、实例解析"></a>三、实例解析</h3><p>为了更好地理解这些概念，我们可以举一个公路运输的例子。假设不同的起始点和目的地需要修不同高速公路（Topic），高速公路上可以提供多条车道（Partition），流量大的公路多修几条车道保证畅通，流量小的公路少修几条车道避免浪费。收费站好比消费者，车多的时候多开几个一起收费避免堵在路上，车少的时候开几个让汽车并道就好了。如果没有车道（Partition），一条公路（Topic）对应的车辆集在分布式集群服务组中，就会分布不均匀，即可能导致某段公路上的车辆很多，若此公路的车流量很大的情况下，该段公路就可能导致压力很大，吞吐也容易导致瓶颈。</p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>通过以上分析，我们可以得出以下结论：</p><ol><li>Topic是逻辑概念，用于对数据流进行分类和组织；Partition是物理概念，用于实现数据的高可用性和容错性；</li><li>Groups是消费者组织形式，多个消费者组成一个Group共享一个Topic的消息；Brokers是Kafka集群中的实体，负责存储和管理Topic的Partition副本；</li><li>Kafka通过Topic、Partition、Groups和Brokers的组合，实现了高效的分布式流处理平台。在实际应用中，需要根据业务需求合理配置这些参数，以获得最佳的性能和可靠性。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Kafka面经</title>
      <link href="/2024/05/03/kafka-question/"/>
      <url>/2024/05/03/kafka-question/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是kafka"><a href="#什么是kafka" class="headerlink" title="什么是kafka"></a><strong>什么是kafka</strong></h2><p>Kafka是分布式发布-订阅消息系统，它最初是由LinkedIn公司开发的，之后成为Apache项目的一部分，Kafka是一个分布式，可划分的，冗余备份的持久性的日志服务，它主要用于处理流式数据。</p><h2 id="为什么要使用-kafka，为什么要使用消息队列"><a href="#为什么要使用-kafka，为什么要使用消息队列" class="headerlink" title="为什么要使用 kafka，为什么要使用消息队列"></a>为什么要使用 kafka，为什么要使用消息队列</h2><p>缓冲和削峰：上游数据时有突发流量，下游可能扛不住，或者下游没有足够多的机器来保证冗余，kafka在中间可以起到一个缓冲的作用，把消息暂存在kafka中，下游服务就可以按照自己的节奏进行慢慢处理。</p><p>解耦和扩展性：项目开始的时候，并不能确定具体需求。消息队列可以作为一个接口层，解耦重要的业务流程。只需要遵守约定，针对数据编程即可获取扩展能力。</p><p>冗余：可以采用一对多的方式，一个生产者发布消息，可以被多个订阅topic的服务消费到，供多个毫无关联的业务使用。</p><p>健壮性：消息队列可以堆积请求，所以消费端业务即使短时间死掉，也不会影响主要业务的正常进行。</p><p>异步通信：很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p><h2 id="Kafka中的ISR、AR又代表什么？ISR的伸缩又指什么"><a href="#Kafka中的ISR、AR又代表什么？ISR的伸缩又指什么" class="headerlink" title="Kafka中的ISR、AR又代表什么？ISR的伸缩又指什么"></a>Kafka中的ISR、AR又代表什么？ISR的伸缩又指什么</h2><p>ISR:In-Sync Replicas 副本同步队列</p><p>AR:Assigned Replicas 所有副本</p><p>ISR是由leader维护，follower从leader同步数据有一些延迟（包括延迟时间replica.lag.time.max.ms和延迟条数replica.lag.max.messages两个维度, 当前最新的版本0.10.x中只支持replica.lag.time.max.ms这个维度），任意一个超过阈值都会把follower剔除出ISR, 存入OSR（Outof-Sync Replicas）列表，新加入的follower也会先存放在OSR中。AR&#x3D;ISR+OSR。</p><h2 id="kafka中的broker-是干什么的"><a href="#kafka中的broker-是干什么的" class="headerlink" title="kafka中的broker 是干什么的"></a><strong>kafka中的broker 是干什么的</strong></h2><p>broker 是消息的代理，Producers往Brokers里面的指定Topic中写消息，Consumers从Brokers里面拉取指定Topic的消息，然后进行业务处理，broker在中间起到一个代理保存消息的中转站。</p><h2 id="kafka中的-zookeeper-起到什么作用，可以不用zookeeper么"><a href="#kafka中的-zookeeper-起到什么作用，可以不用zookeeper么" class="headerlink" title="kafka中的 zookeeper 起到什么作用，可以不用zookeeper么"></a>kafka中的 zookeeper 起到什么作用，可以不用zookeeper么</h2><p>zookeeper 是一个分布式的协调组件，早期版本的kafka用zk做meta信息存储，consumer的消费状态，group的管理以及 offset的值。考虑到zk本身的一些因素以及整个架构较大概率存在单点问题，新版本中逐渐弱化了zookeeper的作用。新的consumer使用了kafka内部的group coordination协议，也减少了对zookeeper的依赖，但是broker依然依赖于ZK，zookeeper 在kafka中还用来选举controller 和 检测broker是否存活等等。</p><h2 id="kafka-follower如何与leader同步数据"><a href="#kafka-follower如何与leader同步数据" class="headerlink" title="kafka follower如何与leader同步数据"></a>kafka follower如何与leader同步数据</h2><p>Kafka的复制机制既不是完全的同步复制，也不是单纯的异步复制。完全同步复制要求All Alive Follower都复制完，这条消息才会被认为commit，这种复制方式极大的影响了吞吐率。而异步复制方式下，Follower异步的从Leader复制数据，数据只要被Leader写入log就被认为已经commit，这种情况下，如果leader挂掉，会丢失数据，kafka使用ISR的方式很好的均衡了确保数据不丢失以及吞吐率。Follower可以批量的从Leader复制数据，而且Leader充分利用磁盘顺序读以及send file(zero copy)机制，这样极大的提高复制性能，内部批量写磁盘，大幅减少了Follower与Leader的消息量差。</p><h2 id="什么情况下一个-broker-会从-isr中踢出去"><a href="#什么情况下一个-broker-会从-isr中踢出去" class="headerlink" title="什么情况下一个 broker 会从 isr中踢出去"></a>什么情况下一个 broker 会从 isr中踢出去</h2><p>leader会维护一个与其基本保持同步的Replica列表，该列表称为ISR(in-sync Replica)，每个Partition都会有一个ISR，而且是由leader动态维护 ，如果一个follower比一个leader落后太多，或者超过一定时间未发起数据复制请求，则leader将其从ISR中移除 </p><h2 id="kafka-为什么那么快"><a href="#kafka-为什么那么快" class="headerlink" title="kafka 为什么那么快"></a>kafka 为什么那么快</h2><ul><li>Cache Filesystem Cache PageCache缓存</li><li>顺序写 由于现代的操作系统提供了预读和写技术，磁盘的顺序写大多数情况下比随机写内存还要快。</li><li>Zero-copy 零拷技术减少拷贝次数</li><li>Batching of Messages 批量量处理。合并小的请求，然后以流的方式进行交互，直顶网络上限。</li><li>Pull 拉模式 使用拉模式进行消息的获取消费，与消费端处理能力相符。</li></ul><h2 id="kafka-producer如何优化打入速度"><a href="#kafka-producer如何优化打入速度" class="headerlink" title="kafka producer如何优化打入速度"></a>kafka producer如何优化打入速度</h2><ul><li>增加线程</li><li>提高 batch.size</li><li>增加更多 producer 实例</li><li>增加 partition 数</li><li>设置 acks&#x3D;-1 时，如果延迟增大：可以增大 num.replica.fetchers（follower 同步数据的线程数）来调解；</li><li>跨数据中心的传输：增加 socket 缓冲区设置以及 OS tcp 缓冲区设置。</li></ul><h2 id="kafka-producer-打数据，ack-为-0，-1，-1-的时候代表啥，-设置-1-的时候，什么情况下，leader-会认为一条消息-commit了"><a href="#kafka-producer-打数据，ack-为-0，-1，-1-的时候代表啥，-设置-1-的时候，什么情况下，leader-会认为一条消息-commit了" class="headerlink" title="kafka producer 打数据，ack 为 0， 1， -1 的时候代表啥， 设置 -1 的时候，什么情况下，leader 会认为一条消息 commit了"></a>kafka producer 打数据，ack 为 0， 1， -1 的时候代表啥， 设置 -1 的时候，什么情况下，leader 会认为一条消息 commit了</h2><ol><li>1（默认） 数据发送到Kafka后，经过leader成功接收消息的的确认，就算是发送成功了。在这种情况下，如果leader宕机了，则会丢失数据。</li><li>0 生产者将数据发送出去就不管了，不去等待任何返回。这种情况下数据传输效率最高，但是数据可靠性确是最低的。</li><li>-1 producer需要等待ISR中的所有follower都确认接收到数据后才算一次发送完成，可靠性最高。当ISR中所有Replica都向Leader发送ACK时，leader才commit，这时候producer才能认为一个请求中的消息都commit了。</li></ol><h2 id="kafka-unclean-配置代表啥，会对-spark-streaming-消费有什么影响"><a href="#kafka-unclean-配置代表啥，会对-spark-streaming-消费有什么影响" class="headerlink" title="kafka unclean 配置代表啥，会对 spark streaming 消费有什么影响"></a>kafka unclean 配置代表啥，会对 spark streaming 消费有什么影响</h2><p>unclean.leader.election.enable 为true的话，意味着非ISR集合的broker 也可以参与选举，这样有可能就会丢数据，spark streaming在消费过程中拿到的 end offset 会突然变小，导致 spark streaming job挂掉。如果unclean.leader.election.enable参数设置为true，就有可能发生数据丢失和数据不一致的情况，Kafka的可靠性就会降低；而如果unclean.leader.election.enable参数设置为false，Kafka的可用性就会降低。</p><h2 id="如果leader-crash时，ISR为空怎么办"><a href="#如果leader-crash时，ISR为空怎么办" class="headerlink" title="如果leader crash时，ISR为空怎么办"></a>如果leader crash时，ISR为空怎么办</h2><p>kafka在Broker端提供了一个配置参数：unclean.leader.election,这个参数有两个值：</p><p>true（默认）：允许不同步副本成为leader，由于不同步副本的消息较为滞后，此时成为leader，可能会出现消息不一致的情况。</p><p>false：不允许不同步副本成为leader，此时如果发生ISR列表为空，会一直等待旧leader恢复，降低了可用性。</p><h2 id="kafka的message格式是什么样的"><a href="#kafka的message格式是什么样的" class="headerlink" title="kafka的message格式是什么样的"></a>kafka的message格式是什么样的</h2><p>一个Kafka的Message由一个固定长度的header和一个变长的消息体body组成</p><p>header部分由一个字节的magic(文件格式)和四个字节的CRC32(用于判断body消息体是否正常)构成。</p><p>当magic的值为1的时候，会在magic和crc32之间多一个字节的数据：attributes(保存一些相关属性，</p><p>比如是否压缩、压缩格式等等);如果magic的值为0，那么不存在attributes属性</p><p>body是由N个字节构成的一个消息体，包含了具体的key&#x2F;value消息</p><h2 id="kafka中consumer-group-是什么概念"><a href="#kafka中consumer-group-是什么概念" class="headerlink" title="kafka中consumer group 是什么概念"></a>kafka中consumer group 是什么概念</h2><p>同样是逻辑上的概念，是Kafka实现单播和广播两种消息模型的手段。同一个topic的数据，会广播给不同的group；同一个group中的worker，只有一个worker能拿到这个数据。换句话说，对于同一个topic，每个group都可以拿到同样的所有数据，但是数据进入group后只能被其中的一个worker消费。group内的worker可以使用多线程或多进程来实现，也可以将进程分散在多台机器上，worker的数量通常不超过partition的数量，且二者最好保持整数倍关系，因为Kafka在设计时假定了一个partition只能被一个worker消费（同一group内）。</p><h2 id="Kafka中的消息是否会丢失和重复消费？"><a href="#Kafka中的消息是否会丢失和重复消费？" class="headerlink" title="Kafka中的消息是否会丢失和重复消费？"></a>Kafka中的消息是否会丢失和重复消费？</h2><p>要确定Kafka的消息是否丢失或重复，从两个方面分析入手：消息发送和消息消费。</p><h3 id="1-消息发送"><a href="#1-消息发送" class="headerlink" title="1. 消息发送"></a>1. 消息发送</h3><p>Kafka消息发送有两种方式：同步（sync）和异步（async），默认是同步方式，可通过producer.type属性进行配置。Kafka通过配置request.required.acks属性来确认消息的生产：</p><ul><li>0—表示不进行消息接收是否成功的确认；</li><li>1—表示当Leader接收成功时确认；</li><li>-1—表示Leader和Follower都接收成功时确认；</li></ul><p>综上所述，有6种消息生产的情况，下面分情况来分析消息丢失的场景：</p><p>（1）acks&#x3D;0，不和Kafka集群进行消息接收确认，则当网络异常、缓冲区满了等情况时，消息可能丢失；</p><p>（2）acks&#x3D;1、同步模式下，只有Leader确认接收成功后但挂掉了，副本没有同步，数据可能丢失；</p><h3 id="2-消息消费"><a href="#2-消息消费" class="headerlink" title="2. 消息消费"></a>2. 消息消费</h3><p>Kafka消息消费有两个consumer接口，Low-level API和High-level API：</p><p>Low-level API：消费者自己维护offset等值，可以实现对Kafka的完全控制；</p><p>High-level API：封装了对parition和offset的管理，使用简单；</p><p>如果使用高级接口High-level API，可能存在一个问题就是当消息消费者从集群中把消息取出来、并提交了新的消息offset值后，还没来得及消费就挂掉了，那么下次再消费时之前没消费成功的消息就“诡异”的消失了；</p><p><strong>解决办法：</strong></p><p>针对消息丢失：同步模式下，确认机制设置为-1，即让消息写入Leader和Follower之后再确认消息发送成功；异步模式下，为防止缓冲区满，可以在配置文件设置不限制阻塞超时时间，当缓冲区满时让生产者一直处于阻塞状态；</p><p>针对消息重复：将消息的唯一标识保存到外部介质中，每次消费时判断是否处理过即可。</p><h2 id="为什么Kafka不支持读写分离？"><a href="#为什么Kafka不支持读写分离？" class="headerlink" title="为什么Kafka不支持读写分离？"></a>为什么Kafka不支持读写分离？</h2><p>在 Kafka 中，生产者写入消息、消费者读取消息的操作都是与 leader 副本进行交互的，从 而实现的是一种主写主读的生产消费模型。</p><p>Kafka 并不支持主写从读，因为主写从读有 2 个很明 显的缺点:</p><p>(1) 数据一致性问题。数据从主节点转到从节点必然会有一个延时的时间窗口，这个时间 窗口会导致主从节点之间的数据不一致。某一时刻，在主节点和从节点中 A 数据的值都为 X， 之后将主节点中 A 的值修改为 Y，那么在这个变更通知到从节点之前，应用读取从节点中的 A 数据的值并不为最新的 Y，由此便产生了数据不一致的问题。</p><p>(2) 延时问题。类似 Redis 这种组件，数据从写入主节点到同步至从节点中的过程需要经 历网络→主节点内存→网络→从节点内存这几个阶段，整个过程会耗费一定的时间。而在 Kafka 中，主从同步会比 Redis 更加耗时，它需要经历网络→主节点内存→主节点磁盘→网络→从节 点内存→从节点磁盘这几个阶段。对延时敏感的应用而言，主写从读的功能并不太适用。</p><h2 id="Kafka中是怎么体现消息顺序性的？"><a href="#Kafka中是怎么体现消息顺序性的？" class="headerlink" title="Kafka中是怎么体现消息顺序性的？"></a>Kafka中是怎么体现消息顺序性的？</h2><p>kafka每个partition中的消息在写入时都是有序的，消费时，每个partition只能被每一个group中的一个消费者消费，保证了消费时也是有序的。</p><p>整个topic不保证有序。如果为了保证topic整个有序，那么将partition调整为1.</p><h2 id="消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset-1"><a href="#消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset-1" class="headerlink" title="消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset+1?"></a>消费者提交消费位移时提交的是当前消费到的最新消息的offset还是offset+1?</h2><p>offset+1</p><h2 id="kafka如何实现延迟队列？"><a href="#kafka如何实现延迟队列？" class="headerlink" title="kafka如何实现延迟队列？"></a>kafka如何实现延迟队列？</h2><p>Kafka并没有使用JDK自带的Timer或者DelayQueue来实现延迟的功能，而是基于时间轮自定义了一个用于实现延迟功能的定时器（SystemTimer）。JDK的Timer和DelayQueue插入和删除操作的平均时间复杂度为O(nlog(n))，并不能满足Kafka的高性能要求，而基于时间轮可以将插入和删除操作的时间复杂度都降为O(1)。时间轮的应用并非Kafka独有，其应用场景还有很多，在Netty、Akka、Quartz、Zookeeper等组件中都存在时间轮的踪影。</p><p>底层使用数组实现，数组中的每个元素可以存放一个TimerTaskList对象。TimerTaskList是一个环形双向链表，在其中的链表项TimerTaskEntry中封装了真正的定时任务TimerTask.</p><p>Kafka中到底是怎么推进时间的呢？Kafka中的定时器借助了JDK中的DelayQueue来协助推进时间轮。具体做法是对于每个使用到的TimerTaskList都会加入到DelayQueue中。Kafka中的TimingWheel专门用来执行插入和删除TimerTaskEntry的操作，而DelayQueue专门负责时间推进的任务。再试想一下，DelayQueue中的第一个超时任务列表的expiration为200ms，第二个超时任务为840ms，这里获取DelayQueue的队头只需要O(1)的时间复杂度。如果采用每秒定时推进，那么获取到第一个超时的任务列表时执行的200次推进中有199次属于“空推进”，而获取到第二个超时任务时有需要执行639次“空推进”，这样会无故空耗机器的性能资源，这里采用DelayQueue来辅助以少量空间换时间，从而做到了“精准推进”。Kafka中的定时器真可谓是“知人善用”，用TimingWheel做最擅长的任务添加和删除操作，而用DelayQueue做最擅长的时间推进工作，相辅相成。</p><h2 id="Kafka中的事务是怎么实现的？"><a href="#Kafka中的事务是怎么实现的？" class="headerlink" title="Kafka中的事务是怎么实现的？"></a>Kafka中的事务是怎么实现的？</h2><p>参考：<a href="https://link.zhihu.com/?target=https://blog.csdn.net/u013256816/article/details/89135417">Kafka科普系列 | Kafka中的事务是什么样子的？</a></p><h2 id="Kafka中有那些地方需要选举？这些地方的选举策略又有哪些？"><a href="#Kafka中有那些地方需要选举？这些地方的选举策略又有哪些？" class="headerlink" title="Kafka中有那些地方需要选举？这些地方的选举策略又有哪些？"></a>Kafka中有那些地方需要选举？这些地方的选举策略又有哪些？</h2><p><a href="https://link.zhihu.com/?target=https://blog.csdn.net/yanshu2012/article/details/54894629">kafka leader选举机制原理</a></p>]]></content>
      
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自我介绍</title>
      <link href="/2024/04/26/introduction/"/>
      <url>/2024/04/26/introduction/</url>
      
        <content type="html"><![CDATA[<p><img src="/2024/04/26/introduction/image-20240426150109337.png"></p><p>​     本人来自北京交通大学计算机科学与技术学院，于2020年入学，2024年完成本科学位，并于2024年9月继续攻读研究生，从事计算机方面的研究。</p><p>​在计算机领域，技术每隔三五年就会有巨大的革新，只有持续学习，才能在这个行业生存下去，创建这个博客的初衷，是希望将自己的学习过程记录下来，以供参考。</p><p>​所见有所获，便足以。</p><h3 id="目前主要的语言技术栈"><a href="#目前主要的语言技术栈" class="headerlink" title="目前主要的语言技术栈:"></a>目前主要的语言技术栈:</h3><p><strong>golang</strong>: 构建后端服务器，gin接口自带的高并发非常舒服，gorm操作数据库的方式也可圈可点，远程连接服务器也很稳定</p><p><strong>vue,node.js</strong>：前端，配合element-plus与echarts，界面清新简洁，开发效率高</p><p><strong>C</strong>：算法竞赛，各种stl非常方便。</p><p><strong>python</strong>：深度学习，爬虫，数据分析。</p><p>这是我的<a href="https://github.com/dianayyds">github地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 自我认知 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo与typora结合</title>
      <link href="/2024/04/26/hexo-typora/"/>
      <url>/2024/04/26/hexo-typora/</url>
      
        <content type="html"><![CDATA[<h3 id="解决hexo插入图片无法显示的问题"><a href="#解决hexo插入图片无法显示的问题" class="headerlink" title="解决hexo插入图片无法显示的问题"></a>解决hexo插入图片无法显示的问题</h3><p>在md中插入图片十分简单，格式如下:</p><pre class="language-markdown" data-language="markdown"><code class="language-markdown"><span class="token url"><span class="token operator">!</span>[<span class="token content">显示在图片下方的名字</span>](<span class="token url">图片地址</span>)</span></code></pre><p>但是部署的时候，并不是完全把整个文件部署上去，导致了文件的路径很混乱，我查阅了网上许多的资料，下面是我的解决方法：</p><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>在hexo根目录的config里面找到post_asset_folder 设置为true，以后新建文章的时候使用hexo new “文章名字”,会在同文件夹下自动创建和你的文章名字相同的资源文件夹。</p><p><em>注意如果按照网上设置了marked的两个属性，一定全部删掉，属于误人子弟！</em></p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>在hexo根目录下运行:</p><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token function">npm</span> <span class="token function">install</span> https://github.com/CodeFalling/hexo-asset-image <span class="token parameter variable">--save</span></code></pre><p>解析图片的插件</p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>进入typora中点击文件-&gt;偏好设置，配置如下:</p><p><img src="/2024/04/26/hexo-typora/image-20240426132030054.png"></p><p>使得你在粘贴进typora的时候，自动保存图片并指定图片路径</p><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><p>在hexo根目录的scaffolds-&gt;post中添加设置：</p><pre class="language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">typora-root-url</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#123;</span> title <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>以后每次新建博客都会在front-matter中出现 typora-root-url: “标题名字”,粘贴图片的时候就会显示相对路径了</p><h4 id="这样就完成了"><a href="#这样就完成了" class="headerlink" title="这样就完成了"></a>这样就完成了</h4><p>可以直接把任意图片粘贴进typora中，部署和预览都不需要其他操作</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动态表单自动生成</title>
      <link href="/2024/04/24/form-generator/"/>
      <url>/2024/04/24/form-generator/</url>
      
        <content type="html"><![CDATA[<h2 id="！需要全局绑定element-plus，否则无法使用"><a href="#！需要全局绑定element-plus，否则无法使用" class="headerlink" title="！需要全局绑定element-plus，否则无法使用"></a>！需要全局绑定element-plus，否则无法使用</h2><h3 id="首先在vscode的插件中搜索form-generator-plugin并下载"><a href="#首先在vscode的插件中搜索form-generator-plugin并下载" class="headerlink" title="首先在vscode的插件中搜索form-generator-plugin并下载"></a>首先在vscode的插件中搜索form-generator-plugin并下载</h3><p><img src="/2024/04/24/form-generator/image-20240425161304886.png"></p><p>下载完成后,在任意的文件夹右键，可以看到打开表单设计器并点击:<br><img src="/2024/04/24/form-generator/image-20240425161419356.png"></p><p>打开后进入界面,中间是布局，左侧是你可以拖入的组件，右侧是数据交互，你可以根据自己想要的样式去拖动左侧的组件进入中间去搭配。</p><p><img src="/2024/04/24/form-generator/image-20240425162538779.png"></p><p>那么如何把表单的数据与我们自己的系统进行交互呢？这里我建议读者先行了解一下element-plus的表单功能，因为这个表单生成器就是基于<a href="https://element-plus.org/zh-CN/component/form.html">el-form</a>来实现的，感兴趣的朋友可以自行学习，我们以这个界面为例，点击运行，生成类型选择页面，点击template,即html来讲解一下右侧的组件属性与表单属性分别对应的意思.以下为对应的html代码：</p><p><img src="/2024/04/24/form-generator/image-20240425162658036.png"></p><p>为了方便朋友们理解，先明确一些概念，首先我们生成的这一整个东西，叫做一个表单，其中每一行，比如说ip地址，指的是一个输入框，我们这里定义了1个表单，5个输入框。每一个输入框的组件属性各不相同，但是所有输入框的表单属性是一致的，因为他们属于一个表单</p><h3 id="表单属性"><a href="#表单属性" class="headerlink" title="表单属性"></a>表单属性</h3><p><img src="/2024/04/24/form-generator/image-20240425162238649.png"></p><p>表单属性中，表单名elForm是容器的ref，用于进行快速定位表单，属于js的内容。表单模型是值整个表单的数据都绑定在了sshInfo这一个对象中，点击script，可以看到sshInfo已经给你定义好了：其中就包括了组件属性中的各个输入框的字段名，至于校验模型，则封装了对于每一个输入框的校验规则，校验是否符合规范，初学者可以把他设置为空，不予理会。</p><p><img src="/2024/04/24/form-generator/image-20240425162908466.png"></p><h3 id="组件属性"><a href="#组件属性" class="headerlink" title="组件属性"></a>组件属性</h3><p><img src="/2024/04/24/form-generator/image-20240425163243908.png"></p><p>上面也提到了，字段名就是这个输入框所对应的sshInfo中哪一个数据，其他的配置都是样式之类的，自行配置就好了。生成之后，表单的数据会自行改变，也就是所谓的动态渲染，属于是非常节省工作量了。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
